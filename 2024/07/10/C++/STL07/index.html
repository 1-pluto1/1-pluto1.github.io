<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>STL学习打卡Day07 - Pluto&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Pluto&#039;s Blog"><meta name="msapplication-TileImage" content="https://cdn.jsdelivr.net/gh/1-pluto1/blog_imgs/b_0b65080deefa163507d3aa4c6a7a5e07.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Pluto&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="STL学习"><meta property="og:type" content="article"><meta property="og:title" content="STL学习打卡Day07"><meta property="og:url" content="http://example.com/2024/07/10/C++/STL07/"><meta property="og:site_name" content="Pluto&#039;s Blog"><meta property="og:description" content="STL学习"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/1-pluto1/blog_imgs/avatar.jpg"><meta property="article:published_time" content="2024-07-10T17:00:29.000Z"><meta property="article:modified_time" content="2025-05-31T21:20:14.664Z"><meta property="article:author" content="Pluto"><meta property="article:tag" content="数据结构算法"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://cdn.jsdelivr.net/gh/1-pluto1/blog_imgs/avatar.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2024/07/10/C++/STL07/"},"headline":"Pluto's Blog","image":["https://cdn.jsdelivr.net/gh/1-pluto1/blog_imgs/avatar.jpg"],"datePublished":"2024-07-10T17:00:29.000Z","dateModified":"2025-05-31T21:20:14.664Z","author":{"@type":"Person","name":"Pluto"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject"}},"description":"STL学习"}</script><link rel="canonical" href="http://example.com/2024/07/10/C++/STL07/"><link rel="icon" href="https://cdn.jsdelivr.net/gh/1-pluto1/blog_imgs/b_0b65080deefa163507d3aa4c6a7a5e07.jpg"><meta name="referrer" content="no-referrer-when-downgrade"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/6.0.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/11.7.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="/js/globalUtils.js"></script><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.10.0/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.8.1/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdnjs.loli.net/ajax/libs/pace/1.2.4/pace.min.js"></script><script async="" referrerpolicy="no-referrer" src="//cdn.jsdelivr.net/npm/leancloud-storage@3/dist/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script src="/js/md5.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://cdn.jsdelivr.net/gh/1-pluto1/blog_imgs/b_0b65080deefa163507d3aa4c6a7a5e07.jpg" alt="Pluto&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/1-pluto1"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><!--!--><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="https://cdn.jsdelivr.net/gh/1-pluto1/blog_imgs/avatar.jpg" alt="STL学习打卡Day07"></span></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2024-07-10  <a class="commentCountImg" href="/2024/07/10/C++/STL07/#comment-container"><span class="display-none-class">/2024/07/10/C++/STL07/</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="ec2c34eb8f9023635d4e034c4e51f5aa">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>21 分钟  <i class="fas fa-pencil-alt"> </i>3.1 k</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">STL学习打卡Day07</h1><div class="content"><p>STL学习</p>
<span id="more"></span>

<h3 id="十三、STL函数"><a href="#十三、STL函数" class="headerlink" title="十三、STL函数"></a>十三、STL函数</h3><p><code>beg</code>为序列的初始地址</p>
<p><code>end</code>为序列的尾地址</p>
<h4 id="accumulate"><a href="#accumulate" class="headerlink" title="accumulate"></a><strong>accumulate</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">accumulate</span>(beg, end, init)</span><br></pre></td></tr></table></figure>

<p>复杂度: O(N)</p>
<p>作用：对一个序列的元素求和</p>
<p><code>init</code>为对序列元素求和的<strong>初始值</strong></p>
<p>返回值类型：与<code>init</code> 相同</p>
<ul>
<li><p><strong>基础累加求和：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对[0,2]区间求和，初始值为0，结果为0 + 1 + 3 + 5 = 9</span></span><br><span class="line"><span class="type">int</span> res1 = <span class="built_in">accumulate</span>(a, a + <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对[0,3]区间求和，初始值为5，结果为5 + 1 + 3 + 5 + 9 = 23</span></span><br><span class="line"><span class="type">int</span> res2 = <span class="built_in">accumulate</span>(a, a + <span class="number">4</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>自定义二元对象求和</strong></p>
<p>使用lambda表达式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    ll num;</span><br><span class="line">&#125; st[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    st[i].num = i + <span class="number">10000000000</span>;</span><br><span class="line"><span class="comment">//返回值类型与init一致，同时注意参数类型（a）也要一样</span></span><br><span class="line"><span class="comment">//初始值为1，累加1+10000000001+10000000002+10000000003=30000000007</span></span><br><span class="line">ll res = <span class="built_in">accumulate</span>(st + <span class="number">1</span>, st + <span class="number">4</span>, <span class="number">1ll</span>, [](ll a,node b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b.num;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="atoi"><a href="#atoi" class="headerlink" title="atoi"></a><strong>atoi</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">atoi</span>(<span class="type">const</span> <span class="type">char</span> *)</span><br></pre></td></tr></table></figure>

<p>将字符串转换为<code>int</code>类型</p>
<p>注意参数为<code>char</code>型数组，如果需要将string类型转换为int类型，可以使用<code>stoi</code>函数（参考下文），或者将<code>string</code>类型转换为<code>const char *</code>类型。</p>
<p>关于输出数字的范围：<br><code>atoi</code><strong>不做</strong>范围检查，如果超出上界，输出上界，超出下界，输出下界。<br><code>stoi</code><strong>会做</strong>范围检查，默认必须在<code>int</code>范围内，如果超出范围，会出现RE（Runtime Error）错误。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line"><span class="type">int</span> a = <span class="built_in">atoi</span>(s.<span class="built_in">c_str</span>());</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 1234</span></span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[] = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line"><span class="type">int</span> a = <span class="built_in">atoi</span>(s);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="fill"><a href="#fill" class="headerlink" title="fill"></a><strong>fill</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fill</span>(beg, end, num)</span><br></pre></td></tr></table></figure>

<p>复杂度： O(N)</p>
<p>一个序列进行初始化赋值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对a数组的所有元素赋1</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">fill</span>(a, a + <span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//1 1 1 1 1</span></span><br></pre></td></tr></table></figure>

<p>注意区分memset：</p>
<p><code>memset()</code>是按<strong>字节</strong>进行赋值，对于初始化赋<code>0</code>或<code>-1</code>有比较好的效果.</p>
<p>如果赋某个特定的数会<strong>出错</strong>，赋值特定的数建议使用<code>fill()</code></p>
<h4 id="is-sorted"><a href="#is-sorted" class="headerlink" title="is_sorted"></a><strong>is_sorted</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">is_sorted</span>(beg, end)</span><br></pre></td></tr></table></figure>

<p>复杂度： O (N)</p>
<p>判断序列是否有序（升序），返回<code>bool</code>值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果序列有序，输出YES</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">is_sorted</span>(a, a + n))</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="iota"><a href="#iota" class="headerlink" title="iota"></a><strong>iota</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">iota</span>(beg, end)</span><br></pre></td></tr></table></figure>

<p>让序列递增赋值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="built_in">iota</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : a)</span><br><span class="line">	cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">// 0 1 2 3 4 5 6 7 8 9</span></span><br></pre></td></tr></table></figure>

<h4 id="lower-bound-upper-bound"><a href="#lower-bound-upper-bound" class="headerlink" title="lower_bound + upper_bound"></a><strong>lower_bound + upper_bound</strong></h4><p>复杂度： O(logN)</p>
<p>作用：二分查找</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在a数组中查找第一个大于等于x的元素，返回该元素的地址</span></span><br><span class="line"><span class="built_in">lower_bound</span>(a, a + n, x);</span><br><span class="line"><span class="comment">//在a数组中查找第一个大于x的元素，返回该元素的地址</span></span><br><span class="line"><span class="built_in">upper_bound</span>(a, a + n, x);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果未找到，返回尾地址的下一个位置的地址</span></span><br></pre></td></tr></table></figure>

<h4 id="max-element-min-element"><a href="#max-element-min-element" class="headerlink" title="max_element+min_element"></a><strong>max_element+min_element</strong></h4><p>复杂度： O(N)</p>
<p>找最大最小值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数都是返回地址，需要加*取值</span></span><br><span class="line"><span class="type">int</span> mx = *<span class="built_in">max_element</span>(a, a + n);</span><br><span class="line"><span class="type">int</span> mn = *<span class="built_in">min_element</span>(a, a + n);</span><br></pre></td></tr></table></figure>

<h4 id="max-min"><a href="#max-min" class="headerlink" title="max+min"></a><strong>max+min</strong></h4><p>复杂度： O(1)<br>找多个元素的最大值和最小值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找a，b的最大值和最小值</span></span><br><span class="line">mx = <span class="built_in">max</span>(a, b);</span><br><span class="line">mn = <span class="built_in">min</span>(a, b);</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到a,b,c,d的最大值和最小值</span></span><br><span class="line">mx = <span class="built_in">max</span>(&#123;a, b, c, d&#125;);</span><br><span class="line">mn = <span class="built_in">min</span>(&#123;a, b, c, d&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="minmax"><a href="#minmax" class="headerlink" title="minmax"></a><strong>minmax</strong></h4><p>复杂度： O(1)</p>
<p>返回一个<code>pair</code>类型，第一个元素是<code>min(a, b)</code>， 第二个元素是<code>max(a, b)</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; t = <span class="built_in">minmax</span>(<span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// t.first = 2, t.second = 4</span></span><br></pre></td></tr></table></figure>

<h4 id="minmax-element"><a href="#minmax-element" class="headerlink" title="minmax_element"></a><strong>minmax_element</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">minmax_element</span>(beg, end)</span><br></pre></td></tr></table></figure>

<p>复杂度： O(N)</p>
<p>返回序列中的最小和最大值组成pair的对应的地址，返回类型为<code>pair&lt;vector&lt;int&gt;::iterator, vector&lt;int&gt;::iterator&gt;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="built_in">iota</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="number">1</span>);</span><br><span class="line"><span class="keyword">auto</span> t = <span class="built_in">minmax_element</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()); <span class="comment">// 返回的是最小值和最大值对应的地址</span></span><br><span class="line"><span class="comment">// *t.first = 1, *t.second = 10 输出对应最小最大值时需要使用指针</span></span><br></pre></td></tr></table></figure>

<h4 id="nth-element"><a href="#nth-element" class="headerlink" title="nth_element"></a><strong>nth_element</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nth_element</span>(beg, nth, end)</span><br></pre></td></tr></table></figure>

<p>复杂度： 平均O(N)</p>
<p>寻找第序列第n小的值</p>
<p><code>nth</code>为一个迭代器，指向序列中的一个元素。第n小的值恰好在<code>nth</code>位置上。</p>
<p>执行<code>nth_element()</code>之后，序列中的元素会围绕nth进行划分：<strong>nth之前的元素都小于等于它，而之后的元素都大于等于它</strong></p>
<p><strong>实例：求序列中的第3小的元素</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nth_element</span>(a, a + <span class="number">2</span>, a + n);</span><br><span class="line">cout &lt;&lt; a[<span class="number">2</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="next-permutation"><a href="#next-permutation" class="headerlink" title="next_permutation"></a><strong>next_permutation</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">next_permutation</span>(beg, end)</span><br></pre></td></tr></table></figure>

<p>复杂度： O(N)</p>
<p>求序列的下一个排列，下一个排列是字典序大一号的排列</p>
<p>返回<code>true</code>或<code>false</code></p>
<ul>
<li><p><code>next_permutation(beg, end)</code></p>
<p>如果是最后一个排列，返回<code>false</code>,否则求出下一个序列后，返回<code>true</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对a序列进行重排</span></span><br><span class="line"><span class="built_in">next_permutation</span>(a, a + n);</span><br></pre></td></tr></table></figure>

<p><strong>应用：求所有的排列</strong></p>
<p>输出<code>a</code>的所有排列</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组a不一定是最小字典序序列，一定注意将它排序</span></span><br><span class="line"><span class="built_in">sort</span>(a, a + n);</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="built_in">next_permutation</span>(a, a + n));</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>prev_permutation(beg, end)</code></p>
<p>求出前一个排列，如果序列为最小的排列，将其重排为最大的排列，返回false</p>
</li>
</ul>
<h4 id="partial-sort"><a href="#partial-sort" class="headerlink" title="partial_sort"></a><strong>partial_sort</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">partial_sort</span>(beg, mid, end)</span><br></pre></td></tr></table></figure>

<p>复杂度： 大概O(NlogM) M为距离</p>
<p>部分排序,排序mid-beg个元素，mid为要排序区间元素的尾后的一个位置</p>
<p>从beg到mid<strong>前</strong>的元素都排好序</p>
<p>对a数组前5个元素排序按从小到大排序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">partial_sort</span>(a, a + <span class="number">5</span>, a + <span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">    cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="comment">//1 2 3 4 5 9 8 10 7 6</span></span><br><span class="line"><span class="comment">//前五个元素都有序</span></span><br></pre></td></tr></table></figure>

<p>也可以添加自定义排序规则:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">partial_sort</span>(beg,mid,end,cmp)</span><br></pre></td></tr></table></figure>

<p>对a的前五个元素都是降序排列</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">partial_sort</span>(a, a + <span class="number">5</span>, a + <span class="number">10</span>, <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">    cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="comment">//10 9 8 7 6 1 2 4 5 3</span></span><br><span class="line"><span class="comment">//前五个元素降序有序</span></span><br></pre></td></tr></table></figure>

<h4 id="random-shuffle"><a href="#random-shuffle" class="headerlink" title="random_shuffle"></a><strong>random_shuffle</strong></h4><p>复杂度： O(N)</p>
<ol>
<li>随机打乱序列的顺序</li>
<li><code>random_shuffle</code> 在 <code>C++14</code> 中被弃用，在 <code>C++17</code> 中被废除，C++11之后应尽量使用<code>shuffle</code>来代替。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="built_in">iota</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), <span class="number">1</span>);<span class="comment">// 序列b递增赋值 1, 2, 3, 4,...</span></span><br><span class="line"><span class="comment">// 对a数组随机重排</span></span><br><span class="line"><span class="built_in">random_shuffle</span>(a, a + n);</span><br><span class="line"><span class="comment">// C++11之后尽量使用shuffle</span></span><br><span class="line"><span class="built_in">shuffle</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<h4 id="reverse"><a href="#reverse" class="headerlink" title="**reverse **"></a>**reverse **</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">reverse</span>(beg,end)</span><br></pre></td></tr></table></figure>

<p>复杂度： O(N)</p>
<p>对序列进行翻转</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());<span class="comment">//对s进行翻转</span></span><br><span class="line">cout &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;<span class="comment">//edcba</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对a数组进行翻转</span></span><br><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">reverse</span>(a, a + <span class="number">4</span>);</span><br><span class="line">cout &lt;&lt; a[<span class="number">0</span>] &lt;&lt; a[<span class="number">1</span>] &lt;&lt; a[<span class="number">2</span>] &lt;&lt; a[<span class="number">3</span>];<span class="comment">//4321</span></span><br></pre></td></tr></table></figure>

<h4 id="set-union-set-intersection-set-difference"><a href="#set-union-set-intersection-set-difference" class="headerlink" title="set_union, set_intersection,set_difference"></a><strong>set_union, set_intersection,set_difference</strong></h4><p>复杂度： O(N+M)</p>
<p>求两个集合的并集，交集，差集。手动实现双指针就可以搞定，嫌麻烦可以使用该函数。</p>
<p><strong>注意</strong>：两个集合必须为有序集合，所以下面演示代码使用了排序。vector容器可以替换成set容器，因为set自动会对元素进行排序。</p>
<p>函数的参数有五个，前两个为第一个容器的首尾迭代器，第三四个为第二个容器的首尾迭代器，最后一个为插入位置，即将结果插入到哪个地址之后。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">8</span>&#125;, b = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()); <span class="comment">// 1 2 4 5 8</span></span><br><span class="line"><span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>()); <span class="comment">// 2 3 5 8 9</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; c, d, e;</span><br><span class="line"><span class="comment">// a并b：1 2 3 4 5 8 9</span></span><br><span class="line"><span class="built_in">set_union</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), <span class="built_in">inserter</span>(c, c.<span class="built_in">begin</span>()));</span><br><span class="line"><span class="comment">// a交b：2 5 8</span></span><br><span class="line"><span class="built_in">set_intersection</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), <span class="built_in">inserter</span>(d, d.<span class="built_in">begin</span>()));</span><br><span class="line"><span class="comment">// a差b： 1 4</span></span><br><span class="line"><span class="built_in">set_difference</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), <span class="built_in">inserter</span>(e, e.<span class="built_in">begin</span>()));</span><br></pre></td></tr></table></figure>



<h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a><strong>sort</strong></h4><p>复杂度： O(NlogN)</p>
<p>作用：对一个序列进行排序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型：</span></span><br><span class="line"><span class="built_in">sort</span>(beg, end);</span><br><span class="line"><span class="built_in">sort</span>(beg, end, cmp);</span><br></pre></td></tr></table></figure>

<p>几种排序的常见操作：</p>
<ul>
<li><p>操作一：对数组正常升序排序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[N]; <span class="comment">// 普通数组定义</span></span><br><span class="line"><span class="comment">// 对 a 数组的[1, n]位置进行从小到大排序</span></span><br><span class="line"><span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(n + <span class="number">1</span>)</span></span>; <span class="comment">// vector数组定义</span></span><br><span class="line"><span class="built_in">sort</span>(b.<span class="built_in">begin</span>() + <span class="number">1</span>, b.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
</li>
<li><p>操作二：使用第三个参数，进行降序排序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对a数组的[0, n-1]位置从大到小排序</span></span><br><span class="line"><span class="built_in">sort</span>(a, a + n, <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"><span class="comment">//对a数组的[0, n-1]位置从小到大排序</span></span><br><span class="line"><span class="built_in">sort</span>(a, a + n, <span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="built_in">sort</span>(b.<span class="built_in">begin</span>() + <span class="number">1</span>, b.<span class="built_in">end</span>()); <span class="comment">// 升序</span></span><br><span class="line"><span class="built_in">sort</span>(b.<span class="built_in">begin</span>() + <span class="number">1</span>, b.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">// 降序</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>操作三：另外一种降序排序方法，针对 <code>vector</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">rbegin</span>(), a.<span class="built_in">rend</span>()); <span class="comment">// 使用反向迭代器进行降序排序</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>操作四：自定义排序规则</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 使用函数自定义排序，定义比较函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//按结构体里面的x值降序排列</span></span><br><span class="line">    <span class="keyword">return</span> a.x &gt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(node, node + n, cmp); <span class="comment">// 只能接受 以函数为形式的自定义排序规则，无法接受以结构体为形式的自定义排序规则</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 或者使用匿名函数自定义排序规则</span></span><br><span class="line"><span class="built_in">sort</span>(node, node + n, [](node a, node b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.x &gt; b.x;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="stable-sort"><a href="#stable-sort" class="headerlink" title="stable_sort"></a><strong>stable_sort</strong></h4><p>复杂度： O(NlogN)</p>
<p>功能和 <code>sort()</code> 基本一样</p>
<p>区别在于<code>stable_sort()</code>能够保证相等元素的相对位置，排序时不会改变相等元素的相对位置</p>
<p>使用用法和<code>sort()</code>一样，见上</p>
<h4 id="stoi"><a href="#stoi" class="headerlink" title="stoi"></a><strong>stoi</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stoi</span>(<span class="type">const</span> string*)</span><br></pre></td></tr></table></figure>

<p>将对应string类型字符串转换为数字，记忆：<code>s -&gt; t 分别对应两个数据类型的某个字母</code></p>
<p>注意参数为<code>string</code>字符串类型。</p>
<p>关于输出数字的范围：</p>
<ul>
<li><code>stoi</code><strong>会做</strong>范围检查，默认必须在<code>int</code>范围内，如果超出范围，会出现RE（Runtime Error）错误。</li>
<li><code>atoi</code><strong>不做</strong>范围检查，如果超出上界，输出上界，超出下界，输出下界</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line"><span class="type">int</span> a = <span class="built_in">stoi</span>(s);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 1234</span></span><br></pre></td></tr></table></figure>

<h4 id="transform"><a href="#transform" class="headerlink" title="transform"></a><strong>transform</strong></h4><p>复杂度： O(N)</p>
<p>作用：使用给定操作，将结果写到dest中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原型：</span></span><br><span class="line"><span class="built_in">transform</span>(beg, end, dest, unaryOp);</span><br></pre></td></tr></table></figure>

<p>一般不怎么使用，徒增记忆负担，不如手动实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将序列开始地址beg到结束地址end大小写转换，把结果存到起始地址为dest的序列中</span></span><br><span class="line"><span class="built_in">transform</span>(beg, end, dest, ::tolower);</span><br><span class="line"><span class="built_in">transform</span>(beg, end, dest, ::toupper)</span><br></pre></td></tr></table></figure>

<h4 id="to-string"><a href="#to-string" class="headerlink" title="to_string"></a><strong>to_string</strong></h4><p>将数字转化为字符串，支持小数（double）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">12345678</span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">to_string</span>(a) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="unique"><a href="#unique" class="headerlink" title="unique"></a><strong>unique</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique</span>(beg, end)</span><br></pre></td></tr></table></figure>

<p>复杂度： O(N)</p>
<p>消除重复元素，返回消除完重复元素的下一个位置的地址</p>
<p>如：<code>a[] = &#123;1, 3, 2, 3, 6&#125;</code>;</p>
<p><code>unique</code> 之后 <code>a</code> 数组为<code>&#123;1, 2, 3, 6, 3&#125;</code>前面为无重复元素的数组，后面则是重复元素移到后面，返回<code>a[4]</code>位置的地址（不重复元素的尾后地址）</p>
<p>消除重复元素一般需要原序列是<strong>有序序列</strong></p>
<p><strong>应用：离散化</strong>:</p>
<ul>
<li><p>方法一：利用数组离散化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    cin &gt;&gt; a[i];</span><br><span class="line">    b[i] = a[i];<span class="comment">//将a数组复制到b数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 排序后 b：&#123;1, 2, 3, 3, 6&#125;</span></span><br><span class="line"><span class="built_in">sort</span>(b, b + n);<span class="comment">//对b数组排序</span></span><br><span class="line"><span class="comment">// 消除重复元素b：&#123;1, 2, 3, 6, 3&#125; 返回的地址为最后一个元素3的地址 </span></span><br><span class="line"><span class="type">int</span> len = <span class="built_in">unique</span>(b, b + n) - b;<span class="comment">//消除 b 的重复元素，并获取长度</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="comment">//因为b有序，查找到的下标就是对应的 相对大小（离散化后的值）</span></span><br><span class="line">    <span class="type">int</span> pos = <span class="built_in">lower_bound</span>(b, b + len, a[i]) - b;<span class="comment">//在b数组中二分查找第一个大于等于a[i]的下标</span></span><br><span class="line">    a[i] = pos; <span class="comment">// 离散化赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法二：利用 <code>vector</code> 进行离散化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; b = a;</span><br><span class="line"><span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">b.<span class="built_in">erase</span>(<span class="built_in">unique</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>()), b.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">	a[i] = <span class="built_in">lower_bound</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), a[i]) - b.<span class="built_in">begin</span>() + <span class="number">1</span>; <span class="comment">// 离散后的数据从1开始   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="gcd"><a href="#gcd" class="headerlink" title="__gcd"></a><strong>__gcd</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__gcd(a, b)</span><br></pre></td></tr></table></figure>

<p>求a和b的最大公约数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__gcd(<span class="number">12</span>,<span class="number">15</span>) = <span class="number">3</span></span><br><span class="line">__gcd(<span class="number">21</span>,<span class="number">0</span>) = <span class="number">21</span></span><br></pre></td></tr></table></figure>

<h4 id="lg"><a href="#lg" class="headerlink" title="__lg"></a><strong>__lg</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__lg(a)</span><br></pre></td></tr></table></figure>

<ol>
<li>求一个数二进制下最高位位于第几位（从<strong>第0位</strong>开始）（或二进制数下有几位）</li>
<li><code>__lg(x)</code>相当于返回⌊ log_2 x ⌋</li>
<li>复杂度O(1)</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__lg(<span class="number">8</span>) = <span class="number">3</span></span><br><span class="line">__lg(<span class="number">15</span>) = <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h4 id="builtin-内置位运算函数"><a href="#builtin-内置位运算函数" class="headerlink" title="_builtin 内置位运算函数"></a>_<strong><em>builtin</em> 内置位运算函数</strong></h4><p>需要注意：内置函数有相应的unsigned lnt和unsigned long long版本，unsigned long long只需要在函数名后面加上ll就可以了，比如__builtin_clzll(x) ，默认是32位unsigned int</p>
<p>很多题目和 long long 数据类型有关，如有需要注意添加 ll</p>
<h4 id="builtin-ffs"><a href="#builtin-ffs" class="headerlink" title="__builtin_ffs"></a><strong>__builtin_ffs</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__builtin_ffs(x)</span><br></pre></td></tr></table></figure>

<p>二进制中对应最后一位<code>1</code>的位数，比如<code>4</code>会返回<code>3</code>（100）</p>
<h4 id="builtin-popcount"><a href="#builtin-popcount" class="headerlink" title="__builtin_popcount"></a><strong>__builtin_popcount</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__builtin_popcount(x)</span><br></pre></td></tr></table></figure>

<p><code>x</code>中<code>1</code>的个数</p>
<h4 id="builtin-ctz"><a href="#builtin-ctz" class="headerlink" title="__builtin_ctz"></a><strong>__builtin_ctz</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__builtin_ctz(x)</span><br></pre></td></tr></table></figure>

<p><code>x</code>末尾<code>0</code>的个数（<code>count tail zero</code>）</p>
<h4 id="builtin-clz"><a href="#builtin-clz" class="headerlink" title="__builtin_clz"></a><strong>__builtin_clz</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__builtin_clz(x)</span><br></pre></td></tr></table></figure>

<p><code>x</code>前导<code>0</code>的个数（<code>count leading zero</code>）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; __builtin_clz(<span class="number">32</span>); <span class="comment">// 26</span></span><br><span class="line"><span class="comment">//因为共有6位,默认数据范围为32位，32 - 6 = 26</span></span><br></pre></td></tr></table></figure>

<h4 id="builtin-parity"><a href="#builtin-parity" class="headerlink" title="__builtin_parity"></a><strong>__builtin_parity</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__builtin_parity(x)</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x`中<span class="number">1</span>的个数的奇偶性， 奇数输出`<span class="number">1</span>`，偶数输出`<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>可参考链接：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/AccRobin/grammar-candies">C++语法糖</a> <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/AccRobin/grammar-candies">https://www.luogu.com.cn/blog/AccRobin/grammar-candies</a></li>
</ol>
</div><div class="article-licensing box"><div class="licensing-title"><p>STL学习打卡Day07</p><p><a href="http://example.com/2024/07/10/C++/STL07/">http://example.com/2024/07/10/C++/STL07/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><a href="http://example.com"><p>Pluto</p></a></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2024-07-10</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2025-05-31</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="recommend-area"><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 相关文章</span><br><span>  1.<a class="is-size-6" href="/2024/07/10/C++/STL06/" target="_blank">STL学习打卡Day06</a><br></span><span>  2.<a class="is-size-6" href="/2024/07/10/C++/STL05/" target="_blank">STL学习打卡Day05</a><br></span><span>  3.<a class="is-size-6" href="/2024/07/09/C++/STL04/" target="_blank">STL学习打卡Day04</a><br></span><span>  4.<a class="is-size-6" href="/2024/07/08/C++/STL03/" target="_blank">STL学习打卡Day03</a><br></span><span>  5.<a class="is-size-6" href="/2024/07/08/C++/STL02/" target="_blank">STL学习打卡Day02</a><br></span><span>  6.<a class="is-size-6" href="/2024/07/07/C++/STL01/" target="_blank">STL学习打卡Day01</a><br></span><span>  7.<a class="is-size-6" href="/2024/07/07/C++/C-06/" target="_blank">侯捷C++面向对象编程下day6</a><br></span><span>  8.<a class="is-size-6" href="/2024/07/07/C++/C-05/" target="_blank">侯捷C++面向对象编程下day5</a><br></span></div></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/css/share.min.css"><div class="social-share"></div><script src="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="https://cdn.jsdelivr.net/gh/1-pluto1/blog_imgs/123501B00F7AB6589E40FE43E701F8C9.jpg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="https://cdn.jsdelivr.net/gh/1-pluto1/blog_imgs/CD85D593847FE4E01CC8386976FEBE69.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2024/07/15/%E7%AE%97%E6%B3%95/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">每日一题01</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2024/07/10/C++/STL06/"><span class="level-item">STL学习打卡Day06</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--><div class="card"><div class="card-content"><div class="title is-5">评论</div><div class="content" id="comment-container"></div><script>var valine = new Valine({
            el: '#comment-container' ,
            notify: false,
            verify: false,
            appId: '21qqhhR0tOxfL1WbwUcK92DR-gzGzoHsz',
            appKey: 'e6qxlPdhLm33xH3N9UZP8Oay',
            placeholder: '留下您的高见！',
            avatar: 'mp',
            avatarForce: false,
            meta: ["nick","mail","link"],
            pageSize: 10,
            visitor: false,
            highlight: true,
            recordIP: false,
            path:'/2024/07/10/C++/STL07/',
            lang:'en',
            enableQQ:true,
            requiredFields:["nick","mail","link"]
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><!--!--><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://cdn.jsdelivr.net/gh/1-pluto1/blog_imgs/b_0b65080deefa163507d3aa4c6a7a5e07.jpg" alt="Pluto"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Pluto</p><p class="is-size-6 is-block">All things come to those who wait.</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>四川成都</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives/"><p class="title">23</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories/"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags/"><p class="title">5</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/1-pluto1" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/1-pluto1"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:im.yang.zhao.edu@gmail.com"><i class="fa fa-envelope"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="WeiChat" href="https://cdn.jsdelivr.net/gh/1-pluto1/blog_imgs/443E347C13A787C5F7DB59948B0B130A.png"><i class="fab fa-weixin"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="QQ" href="https://qm.qq.com/q/gSHKiKzt6g"><i class="fab fa-qq"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="zhihu" href="https://www.zhihu.com/people/10-65-19-7"><i class="fab fa-zhihu"></i></a></div><div><hr><p id="hitokoto">:D 一言句子获取中...</p><script type="text/javascript" defer>function getYiyan(){
                                $.getJSON("https://v1.hitokoto.cn/", function (data) {
                                if(data){
                                    $('#hitokoto').html("");
                                    $('#hitokoto').append("<strong style='color: #3273dc;'>"+data.hitokoto+"</strong>"+
                                    "<p>"+"来源《"+data.from+"》</p><p>提供者-"+data.creator+"</p>");
                                }});}
                                $(function (){getYiyan();$('#hitokoto').click(function(){getYiyan();})});</script></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://leetcode.cn/discuss/post/3141566/ru-he-ke-xue-shua-ti-by-endlesscheng-q3yd/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">LeetCode</span></span><span class="level-right"><span class="level-item tag">leetcode.cn</span></span></a></li><li><a class="level is-mobile" href="https://blog.csdn.net/weixin_73184653?spm=1010.2135.3001.10640" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">CSDN</span></span><span class="level-right"><span class="level-item tag">blog.csdn.net</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新评论</h3><span class="body_hot_comment">加载中，最新评论有1分钟缓存...</span></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/2025/05/31/Research/Buffer%20of%20Thoughts%EF%BC%9AThought-Augmented%20Reasoning%20with%20Large%20Language%20Models/"><img src="https://cdn.jsdelivr.net/gh/1-pluto1/blog_imgs/20250531220408214.png" alt="Buffer of Thoughts：Thought-Augmented Reasoning with Large Language Models"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-05-31T22:03:07.000Z">2025-05-31</time></p><p class="title"><a href="/2025/05/31/Research/Buffer%20of%20Thoughts%EF%BC%9AThought-Augmented%20Reasoning%20with%20Large%20Language%20Models/">Buffer of Thoughts：Thought-Augmented Reasoning with Large Language Models</a></p><p class="categories"><a href="/categories/Research/">Research</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2025/05/31/Research/SUPERCORRECT%EF%BC%9ASUPERVISING%20AND%20CORRECTING%20%20LANGUAGE%20MODELS%20WITH%20ERROR-DRIVEN%20INSIGHTS/"><img src="https://cdn.jsdelivr.net/gh/1-pluto1/blog_imgs/20250531212714676.png" alt="SUPERCORRECT：SUPERVISING AND CORRECTING  LANGUAGE MODELS WITH ERROR-DRIVEN INSIGHTS"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-05-31T21:23:55.000Z">2025-05-31</time></p><p class="title"><a href="/2025/05/31/Research/SUPERCORRECT%EF%BC%9ASUPERVISING%20AND%20CORRECTING%20%20LANGUAGE%20MODELS%20WITH%20ERROR-DRIVEN%20INSIGHTS/">SUPERCORRECT：SUPERVISING AND CORRECTING  LANGUAGE MODELS WITH ERROR-DRIVEN INSIGHTS</a></p><p class="categories"><a href="/categories/Research/">Research</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-05-31T21:20:14.664Z">2025-05-31</time></p><p class="title"><a href="/2025/05/31/%E3%80%90%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B%E3%80%91%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%20Hexo%20%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%9AAmazing%20%E4%B8%BB%E9%A2%98%E3%80%81GitHub%20Pages%20%E9%83%A8%E7%BD%B2%E4%B8%8E%20Github%20actions%20%E8%87%AA%E5%8A%A8%E5%8C%96%EF%BC%8C%E7%BB%93%E5%90%88%20Obsidian%20%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E5%88%9B%E4%BD%9C/"> </a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2025/05/11/Research/ReasonFlux%EF%BC%9A%20Hierarchical%20LLM%20Reasoning%20via%20Scaling%20Thought%20Templates/"><img src="https://github.com/Gen-Verse/ReasonFlux/raw/main/figs/image.png" alt="ReasonFlux阅读"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-05-11T04:35:40.000Z">2025-05-11</time></p><p class="title"><a href="/2025/05/11/Research/ReasonFlux%EF%BC%9A%20Hierarchical%20LLM%20Reasoning%20via%20Scaling%20Thought%20Templates/">ReasonFlux阅读</a></p><p class="categories"><a href="/categories/Research/">Research</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2024/09/19/NLP/%E6%89%8B%E6%92%95transformer/"><img src="https://cdn.jsdelivr.net/gh/1-pluto1/blog_imgs/avatar.jpg" alt="手撕transformer"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-09-19T13:14:00.000Z">2024-09-19</time></p><p class="title"><a href="/2024/09/19/NLP/%E6%89%8B%E6%92%95transformer/">手撕transformer</a></p><p class="categories"><a href="/categories/NLP/">NLP</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/NLP/"><span class="level-start"><span class="level-item">NLP</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Research/"><span class="level-start"><span class="level-item">Research</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2025/05/"><span class="level-start"><span class="level-item">五月 2025</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2024/09/"><span class="level-start"><span class="level-item">九月 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2024/07/"><span class="level-start"><span class="level-item">七月 2024</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/"><span class="tag">数据结构算法</span><span class="tag is-grey-lightest">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"><span class="tag">编程语言</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NLP/"><span class="tag">NLP</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LLM/"><span class="tag">LLM</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ReasoningModel/"><span class="tag">ReasoningModel</span><span class="tag is-grey-lightest">3</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><!--!--><div class="column-right-shadow is-hidden-widescreen"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://cdn.jsdelivr.net/gh/1-pluto1/blog_imgs/b_0b65080deefa163507d3aa4c6a7a5e07.jpg" alt="Pluto&#039;s Blog" height="28"></a><p class="size-small"><span>&copy; 2025 Pluto</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a> &amp; <a href="https://github.com/removeif/hexo-theme-amazing" target="_blank">Amazing</a> <br><span>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br />&nbsp;&nbsp;&nbsp;&nbsp;方便于网友与自己学习交流，如有侵权，请<a href="/message" target="_blank">留言</a>，立即处理]<br /></span><div class="size-small"><span>❤️感谢 <strong><span id="busuanzi_value_site_uv">99+</span></strong> 小伙伴的 <strong><span id="busuanzi_value_site_pv">99+</span></strong> 次光临！❤️</span></div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/1-pluto1"><i class="fab fa-github"></i></a></p></div><div class="sideMusic"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="/js/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><meting-js style="width: auto;height: 2000px;" server="netease" type="playlist" id="7589308811" theme="#2980b9" loop="all" autoplay="false" order="list" storageName="aplayer-setting" lrctype="0" list-max-height="400px" fixed="true"></meting-js></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.10.0/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/javascript" id="MathJax-script" async>MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      },
      svg: {
        fontCache: 'global'
      },
      chtml: {
        matchFontHeight: false
      }
    };</script><script src="https://cdnjs.loli.net/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js"></script><!--!--><script src="/js/main.js" defer></script><script>$.getScript('/js/comment-issue-data.js',function(){loadIssueData('21qqhhR0tOxfL1WbwUcK92DR-gzGzoHsz','e6qxlPdhLm33xH3N9UZP8Oay','akiya','undefined',true);})</script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script><script type="text/javascript">var pjax = new Pjax({
            elements: "a",//代表点击链接就更新
            selectors: [  //代表要更新的节点
                ".section",
                "title"
            ],
            cache: true,
            cacheBust:false
        })

        function loadBusuanzi(){
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js", function () {});
        }

        function loadMathJax() { //加载mathjax
            $.getScript("//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML", function () {
                MathJax.Hub.Config({ tex2jax: { inlineMath: [['$', '$'], ['\(', '\)']] } });
                var math = document.getElementsByClassName("entry-content")[0];
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, math]);
            });
        };

        // 开始 PJAX 执行的函数
        document.addEventListener('pjax:send', function () {
        });
        
        // PJAX 完成之后执行的函数，可以和上面的重载放在一起
        document.addEventListener('pjax:complete', function () {
            $(".section").css({opacity:1});
            if(true){
                $.getScript('/js/comment-issue-data.js',function(){loadIssueData('21qqhhR0tOxfL1WbwUcK92DR-gzGzoHsz','e6qxlPdhLm33xH3N9UZP8Oay','akiya','undefined',true);});
            }
            if(false){
                loadMathJax();
            }
            loadMainJs(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings);
            loadBackTop();
            loadBusuanzi();
            if(typeof loadBanner == 'function'){
                loadBanner();
            }
        });</script></body></html>