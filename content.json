{"posts":[{"title":"","text":"本文使用","link":"/2025/05/31/%E3%80%90%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B%E3%80%91%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%20Hexo%20%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%9AAmazing%20%E4%B8%BB%E9%A2%98%E3%80%81GitHub%20Pages%20%E9%83%A8%E7%BD%B2%E4%B8%8E%20Github%20actions%20%E8%87%AA%E5%8A%A8%E5%8C%96%EF%BC%8C%E7%BB%93%E5%90%88%20Obsidian%20%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E5%88%9B%E4%BD%9C/"},{"title":"侯捷C++面向对象编程上day2","text":"侯捷C++面向对象编程（上）课程打卡 2、构造函数2.1 inline函数 定义类的时候，可以直接在body中定义函数（inline函数，在body中定义完成），也可以只是在body中声明函数 inline内联函数：如果定义的函数是内联函数，那么会运行比较快，尽可能定义为内联函数 在body外，通过inline关键字来指定该函数为inline函数。 注意的是，上面所有的inline函数，都只是我们指定的，希望它为inline，具体是不是，要看编译器来决定 C++ Primer Plus的解释： 内联函数是C++为了提高程序运行速度进行的一项改进。常规函数和内联函数的主要区别不在于编写方式，而在于C++编译器如何将它们组合到程序中。 C++的内联函数的编译代码与其他程序的代码“内联”起来。编译器将使用相应的函数代码替换函数调用。对于内联代码，程序无需跳到另一个位置处执行代码，再跳回来。因此，内联函数的运行速度比常规函数稍快，但是代价是要占据更多内存。 程序员请求将函数设置为内联函数时，该请求不一定会通过，因为编译器可能认为该函数过大或者注意到函数调用了自己，因此不将其作为内联函数，也有些编译器没有启用或者实现这种特性。 2.2 访问级别 数据应该被定义为private级别 函数如果要被外界使用应该定义为public；如果知识内部处理，定义为private。 2.3 ctor构造函数2.3.1ctor的写法方式一：（推荐） 123complex(T r = 0, Ti = o)//函数的名称与class的名称一致 :re(r),im(i) //中间这一行就是初始化 {} 方式二：（不推荐） 12345complex(double r = 0,double i =0){ re = r; //使用赋值进行初始化 im = i;} 如果通过构造函数来创建对象。会自动调用构造函数进行创建。 构造函数名称需要与类的名称一样 函数的参数可以有默认参数 构造函数没有返回类型 2.3.2ctor/函数 重载 构造函数可以有很多个，可以重载；但是上面1 2 两个构造函数冲突了 1complex c2(); //&quot;()&quot;可以不要，一样的 上面的调用方式对于两个构造函数都适用，冲突 1double real () const { return re; } 1void real (double r) { re = r; } //不能有const 同名的函数可以有多个，编译器会编成不同的名称，实际调用哪个就会根据哪个适用 2.3.3 ctor 放在 private 区** 通常构造函数不要放在private中，这样外界没法调用，也就无法创建对象 在设计模式 Singleton（单体）中，将构造函数放在了private中；这个class只有一份，外界想要调用的时候，只能使用定义的 getInstance() 函数来取得这一份；外界无法创建新的对象 2.4 const 常量成员函数 对于不会改变数据内容的函数，一定要加上const 12345{ const complex c1(2, 1); cout &lt;&lt; c1.real(); cout &lt;&lt; c1.imag();} 对于上面调用方式，我们创建一个常量复数然后调用函数输出实部虚部，如果上面real和imag函数定义的时候，没有加const，那么这里函数默认的意思是可能会改变数据，与我们的常量复数就矛盾了，编译器会报错；因此，对于不会改变数据内容的函数，一定一定要加const 3、参数传递与返回值—-引用3.1参数传递 值传递 pass by value，传递value是把整个参数全传过去，尽量不要直接value传递 例 double r 引用传递 pass by reference，传引用相当于传指针，快，形式也漂亮 例 complex&amp; 如果只是为了提升速度，不想改变数据，那么传const引用；这样传进去的东西，不能被修改 例 const complex&amp; 3.2返回值传递 返回值的传递，尽量返回引用 在函数中创建的变量 (local 变量)，要返回——这种情况是不能返回引用的；因为函数结束后函数中创建的变量就消失了，无法引用 传递者无需知道接受者是以reference形式接受——所以用reference形式很便捷 4、友元friend4.1友元 友元：friend，修饰在函数定义之前，表示这个函数可以直接拿该类对象的private数据 123456inline complex&amp; _doapl(complex* ths ,const complex&amp; r){ ths-&gt;re += r.re; //可以直接获得private的函数，不需要函数 ths=&gt;im += r.rm; return *ths;} 如上面所示，声明为friend后，函数可以直接取得re和im，如果不被声明为friend，只能通过 调用real和imag函数来得到，效率极低 4.2相同class的object互相为friends 12345{ complex c1(2, 1); complex c2; c2.func(c1);} 相同class的不同对象互相为友元，即可以直接取另一个object的private data","link":"/2024/07/06/C++/C-02/"},{"title":"侯捷C++面向对象编程上day3","text":"侯捷C++面向对象编程（上）课程打卡 侯捷C++面向对象编程（上）课程打卡 Day35、操作符重载与临时对象5.1操作符重载在C++中，我们可以定义加法等操作符，比如我们可以定义两个是石头的加法 5.1.1成员函数实现成员函数： complex :: function …… 前面带有class的名称（在class里事先声明了的） 12345inline complex&amp; complex::operator += (const complex&amp; r){ return __doapl(this,r);} 所有的成员函数都带有一个隐藏的参数this（是一个指针），this指向调用这个函数的调用者 定义函数的时候，在参数列中不能写出来this，直接用即可 函数里可写可不写，但当传入参数与成员变量名相同时要写 12public: double real () const { return this-&gt;re; } //这里的this-&gt;可省略 1c3 += c2 += c1 //c2加了c1后如果返回void就无法进行c3的操作了 将操作符写为void函数也可以，但为了可以兼容c3+=c2+=c1的形式，写成返回引用更好。 5.1.2 非成员函数实现 非成员函数没有this 应对三种使用方法，写出三种方式 非成员函数是global函数——为了后面两种使用方法 这些函数不能返回引用，必须值传递 在函数中创建的新变量 (local 变量)，要返回 5.1.3 output函数 &lt;&lt; 的重载cout不认识新定义的这种复数，因此也需要对&lt;&lt;进行操作符重载 只能全局函数，不能成员函数——导致使用时方向相反 1234567#include &lt;iostream.h&gt;ostream&amp;operator&lt;&lt;(ostream&amp; os, const complex&amp; x){ return os &lt;&lt; '(' &lt;&lt; real(x) &lt;&lt; ',' &lt;&lt; imag(x) &lt;&lt; ')'; //自定义输出} ostream&amp; 是 cout 的 classname 参数传递：os 在函数中会变化，所以不能加 const 返回值传递：为了避免 cout &lt;&lt; c1 &lt;&lt; conj(c1); 连续输出，不用 void cout &lt;&lt; c1 返回值需要与 cout 类型一致 5.2 临时对象 classname () 创建一个classname类型的临时对象——不需要名称，生命只有一行 6、带指针的类：三大函数 析构函数：~String(); 拷贝构造函数 copy ctor:String (const String&amp; str);——string s3(s1) 拷贝赋值函数copy op= :String&amp; operator=(const String&amp; str);—–s3=s2 编译器默认的是拷贝构造赋值，编译器默认的方式只是拷贝了指针（浅拷贝），而不是指针指向的数据。 alias（别名）和 memory leak（内存泄漏）都是十分危险的 因此，如果类中有指针，一定自己写这两个函数 6.1ctor和dtor（构造和析构函数）6.1.1ctor构造函数这里的new是申请的字符串的空间 123456789101112inlineString::String(const char* cstr = 0){ if (cstr) { // 指定了初值—— String s2(&quot;hello&quot;); m_data = new char[strlen(cstr) + 1]; // 字符串长度 + /0 strcpy(m_data, cstr); } else { // 未指定初值—— String s1(); m_data = new char[1]; *m_data = '\\0'; }} 这里的 new 是申请的指针的空间，String()里面还有一个 new 12String* p = new String(&quot;hello&quot;); delete p; 6.1.2dtor析构函数12345inline String::~String(){ delete[] m_data;} 每一个new都对应一个delete—–一定要释放申请的内存 类对象死亡的时候（离开作用域），析构函数会被自动调用 例：这里结束会调用三次 dtor 123456{ String s1(), String s2(&quot;hello&quot;); String* p = new String(&quot;hello&quot;); delete p;} 6.2 copy ctor 拷贝构造函数123456inlineString::String(const String&amp; str){ m_data = new char[strlen(str.m_data) + 1]; // “str.m_data” 兄弟之间互为友元 strcpy(m_data, str.m_data); // 深拷贝} 12String s1(&quot;hello &quot;);String s2(s1); 6.3 copy op= 拷贝赋值函数 先杀死调用者 重新申请指定大小的空间 复制字符串内容到调用者 1234567891011inlineString&amp; String::operator=(const String &amp; str){ if (this == &amp;str) // 检测自我赋值 self assignment return *this; delete[] m_data; // 第一步 m_data = new char[strlen(str.m_data) + 1]; // 第二步 strcpy(m_data, str.m_data); // 第三步 return *this;} 一定要在开始就检测自我赋值，因为a=a时第一步 delete 了后，会使第三步出现问题 7、堆、栈，内存管理7.1堆和栈Stack 栈，是存在于某一个作用域的一块内存空间。 例如当你调用函数时，函数本身就会产生一个stack用于放置它所接受的参数，以及返回地址；在函数本体内声明的任何变量其所使用的内存块都取自上述的stack Heap 堆，或者称为system heap，是指由操作系统提供的一块global内存空间，程序可以动态分配从中获得若干区块。 可以用new来动态取得 在 stack 中的是自动生成的空间，作用域结束空间会自动释放 在 heap 中的是自己申请的空间，需要自己释放 1234567{ complex c1(1,2); /*c1空间来自stack*/ complex* p = new complex(3); /*complex(3) 是个临时对象 其所用的空间是以new从heap动态分配而得，并由p指向*/} 7.2对象生命周期 stack objects的生命周期 c1就是所谓stack object，其生命在作用域结束之际结束。这种作用域内的object，又称为auto object，因为它会被自动清理（结束自动调用析构函数） 123{ complex c1(1,2);} static local objects 的生命期 若在前面加上 static 后，其会存在到整个程序结束 123{ static complex c2(1,2);} global objects 的生命期 写在任何作用域之外的对象，其生命在整个程序结束之后才结束，你也可以把它视为一种 static object，其作用域是整个程序 1234567...complex c3(1,2);int main(){ ...} heap objects 的生命期 p 所指的便是 heap object，其生命在它被 delete 之际结束 12345{ complex* p = new complex; ... delete p;} 7.3new和delete7.3.1 newnew: 先分配memory，再调用ctor 分配内存：先用一个特殊函数，按 class 的定义分配了两个 double 的大小 转型（忽视） 调用构造函数，赋值(1,2) 7.3.2 deletedelete：先调用 dtor, 再释放 memory 调用析构函数——释放的是 m_date 指向的字符串 Hello 的空间（即构造函数中 new 申请的空间） 释放内存：用一个特殊函数释放了 ps 指向的空间（即String* ps = new String(&quot;Hello&quot;); 中 new 申请的空间） 7.4内存动态分配7.4.1 array new/deletearray new 一定要搭配 array delete new后有**[ ]—&gt; delete后加[ ]** 普通的delete只调用一次析构函数——剩下两个指针的指向的空间没有调用析构函数，内存泄漏 这种情况发生在有指针的类，但最好都这样写 7.4.2 对象的动态内存分配对象与简单的数据类型没有什么不同","link":"/2024/07/07/C++/C-03/"},{"title":"侯捷C++面向对象编程上day1","text":"侯捷C++面向对象编程（上）课程打卡 侯捷C++面向对象编程（上）课程打卡 Day11、头文件与类的声明1.1 C vs C++ C语言中，Data和函数是分别定义，根据类型创建的。这样建立的变量为全局变量。 C++中，将Data和函数包含在一起形成类。使用类实例化出一个对象，即为面向对象。类中的数据和函数都是局部的，不是全局的。 class分类： 无指针成员的类 有指针成员的类 1.2 头文件与类1.2.1头文件引用自己编写的头文件使用双引号。 写法如下： 1处是要写类的声明，2是要写类的具体定义，写1、2的时候发现有些东西需要提前进行声明，就写在0处。 complex.h: 1234567891011121314151617#ifndef _complex_ //防卫式声明，如果没有定义过，那就定义一下。ifndef+define。#define _complex_//如果程序第一次引用，则进行定义，后续不需要重复定义，不需要重复进入下面的过程#include &lt;cmath&gt;class ostream;class complex;complex&amp; _doapl(complex* this ,const complex&amp; r);class complex{ 。。。};complex::function... #endif 1.2.2 class的声明在C++中，struct和class的唯一区别在于默认访问权限不同： struct默认权限为公共 class默认权限为私有 1234567891011121314class complex{ public: complex (double r =0,double i = 0) :re(r),im(i) {} complex&amp; operator += (const complex&amp;); double real() const{return re;} double imag() const{return im;} private: double re,im; friend complex&amp; _doapl (complex*, const complex&amp;);} 1.2.3 模板初识 12345{ complex&lt;double&gt; c1(2.5, 1.5); complex&lt;int&gt; c2(2, 6); ...} 因为实部和虚部的类型不确定，可能是 double float int，定义一个模板类型叫做 T 将T作为一个类型参数来传入，在调用的时候就可以指定类型了 通过在定义类的前面加入一行代码 template&lt;typename T&gt; 来实现","link":"/2024/07/03/C++/C-01/"},{"title":"侯捷C++面向对象编程上day4","text":"侯捷C++面向对象编程（上）课程打卡 侯捷C++面向对象编程（上）课程打卡 Day48、 静态 模板 namespace8.1 static对于非静态的函数和数据： 非静态的成员函数通过this指针来处理不同的数据（一份函数–&gt;多个对象） 对于静态的函数和数据： 静态函数没有this，不能处理一般的数据，只能处理静态的数据。 例1: 12345678910111213141516class Account{public: static double m_rate; //静态变量的声明 static void set_rate(const double&amp; x) { m_rate = x; } //静态函数};double Account::m_rate = 0; //静态变量的定义 一定要有int main(){ //调用静态函数法1——by class name Account::set_rate(5.0); //调用静态函数法2——by object Account a; a.set_rate(7.0); //静态函数与a无关/无this} 例2：设计模式 Singleton（单体） 构造函数放在private中，外界无法调用 设计了getInstance静态函数，来生成并返回唯一的一份 8.2 template可以参考菜鸟教程： https://www.runoob.com/cplusplus/cpp-templates.html 模板是泛型编程的基础，泛型编程以一种独立于任何特定类型的方式编写代码。 模板是创建泛型类或函数的蓝图或者公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。 8.2.1 函数模板模板函数的定义的一般形式如下： 1234template &lt;typename type&gt; ret-type funcname(parameter list){ //函数主体} 在这里，type是函数所使用的数据类型的占位符名称。该名称可以在函数定义中使用。 接下来给出实例，返回两个数的最大值： 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;string&gt; using namespace std; template &lt;typename T&gt;inline T const&amp; Max (T const&amp; a, T const&amp; b) { return a &lt; b ? b:a; } int main (){ int i = 39; int j = 20; cout &lt;&lt; &quot;Max(i, j): &quot; &lt;&lt; Max(i, j) &lt;&lt; endl; double f1 = 13.5; double f2 = 20.7; cout &lt;&lt; &quot;Max(f1, f2): &quot; &lt;&lt; Max(f1, f2) &lt;&lt; endl; string s1 = &quot;Hello&quot;; string s2 = &quot;World&quot;; cout &lt;&lt; &quot;Max(s1, s2): &quot; &lt;&lt; Max(s1, s2) &lt;&lt; endl; return 0;} 当上面的代码被编译和执行时，它会产生下列结果： 123Max(i, j): 39Max(f1, f2): 20.7Max(s1, s2): World 8.2.2 类模板正如我们定义函数模板一样，我们也可以定义类模板。泛型类声明的一般形式如下所示： 12345template &lt;class type&gt; class class-name {...} 在这里，type 是占位符类型名称，可以在类被实例化的时候进行指定。您可以使用一个逗号分隔的列表来定义多个泛型数据类型。 下面的实例定义了类 Stack&lt;&gt;，并实现了泛型方法来对元素进行入栈出栈操作： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;string&gt;#include &lt;stdexcept&gt; using namespace std; template &lt;class T&gt;class Stack { private: vector&lt;T&gt; elems; // 元素 public: void push(T const&amp;); // 入栈 void pop(); // 出栈 T top() const; // 返回栈顶元素 bool empty() const{ // 如果为空则返回真。 return elems.empty(); } }; template &lt;class T&gt;void Stack&lt;T&gt;::push (T const&amp; elem) { // 追加传入元素的副本 elems.push_back(elem); } template &lt;class T&gt;void Stack&lt;T&gt;::pop () { if (elems.empty()) { throw out_of_range(&quot;Stack&lt;&gt;::pop(): empty stack&quot;); } // 删除最后一个元素 elems.pop_back(); } template &lt;class T&gt;T Stack&lt;T&gt;::top () const { if (elems.empty()) { throw out_of_range(&quot;Stack&lt;&gt;::top(): empty stack&quot;); } // 返回最后一个元素的副本 return elems.back(); } int main() { try { Stack&lt;int&gt; intStack; // int 类型的栈 Stack&lt;string&gt; stringStack; // string 类型的栈 // 操作 int 类型的栈 intStack.push(7); cout &lt;&lt; intStack.top() &lt;&lt;endl; // 操作 string 类型的栈 stringStack.push(&quot;hello&quot;); cout &lt;&lt; stringStack.top() &lt;&lt; std::endl; stringStack.pop(); stringStack.pop(); } catch (exception const&amp; ex) { cerr &lt;&lt; &quot;Exception: &quot; &lt;&lt; ex.what() &lt;&lt;endl; return -1; } } 当上面的代码被编译和执行时，它会产生下列结果： 1237helloException: Stack&lt;&gt;::pop(): empty stack 8.3 namespace命名空间被用于作为附加信息来区分不同库中相同名称的函数、类、变量等。使用了命名空间即定义了上下文。本质上，命名空间就是定义了一个范围。 定义命名空间 命名空间的定义使用关键字namespace,后跟命名空间的名称。如下图所示： 123namespace namespace_name{//代码声明} 为了调节带有命名空间的函数或变量，需要在前面加上命名空间的名称。如下图所示： 1name::code;//code可以是变量或者函数 using 指令 可以使用using namespace指令，这样在使用命名空间的时候就可以不用在前面加上命名空间的名称。该指令会告诉编译器，后续的代码使用指定的命名空间的名称。 using 指令也可以用来指定命名空间中的特定项目。例如，如果您只打算使用 std 命名空间中的 cout 部分，您可以使用如下的语句： 1using std::cout; 随后的代码中，在使用 cout 时就可以不用加上命名空间名称作为前缀，但是 std 命名空间中的其他项目仍然需要加上命名空间名称作为前缀 using 指令引入的名称遵循正常的范围规则。名称从使用 using 指令开始是可见的，直到该范围结束。此时，在范围以外定义的同名实体是隐藏的。 不连续的命名空间 命名空间可以定义在几个不同的部分中，因此命名空间是由几个单独定义的部分组成的。一个命名空间的各个组成部分可以分散在多个文件中。 所以，如果命名空间中的某个组成部分需要请求定义在另一个文件中的名称，则仍然需要声明该名称。下面的命名空间定义可以是定义一个新的命名空间，也可以是为已有的命名空间增加新的元素： 1namespace namespace_name { // 代码声明 } 嵌套的命名空间 命名空间可以嵌套，您可以在一个命名空间中定义另一个命名空间. 9、复合 委托9.1 Composition 复合类似于C语言中的结构里面可以有结构—class里面也可以有class deque 是一个已经存在的功能很多的类（两头进出的队列）；利用deque的功能来实现queue的多种操作 该例只是复合的一种情况——设计模式 Adapter 9.1.1 复合下的构造和析构 构造是由内而外 Container 的构造函数，编译器会自动先调用 Component 的 default 构造函数，再执行自己 1注意如果要调用 Component 的其他构造函数需要自己写出来Container::Container(…): Component() { … }; 析构是由外而内 Container 的析构函数会先执行自己，之后编译器调用 Component 的析构函数 9.2 Delegation 委托委托就是 Composition by reference；即通过指针把任务委托给另一个类 复合中，内部和外部是一起出现的；而委托是不同步的 这是一个著名的设计模式——pimpl (pointer to implementation) 或者叫 “编译防火墙” 右边怎么变动都不会影响左边 reference counting 多个指针共享一个 “Hello”；但当a要改变内容时， 系统会单独复制一份出来给a来改，b和c依然在共享 10 继承与多态10.1 Inheritance 继承面向对象程序设计的最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序更加容易。也达到了重用代码功能和提高执行效率的效果。 当创建一个类时，不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。 继承代表了 is a 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。 代码如下： 12345678910// 基类class Animal { // eat() 函数 // sleep() 函数};//派生类class Dog : public Animal { // bark() 函数}; 10.1.1 基类 &amp; 派生类一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下： 1class derived-class: access-specifier base-class 其中，访问修饰符 access-specifier 是 public、protected 或 private 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。 10.1.2 访问控制和继承派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。 我们可以根据访问权限总结出不同的访问类型，如下所示： 访问 public protected private 同一个类 yes yes yes 派生类 yes yes no 外部的类 yes no no 一个派生类继承了所有的基类方法，但下列情况除外： 基类的构造函数、析构函数和拷贝构造函数。 基类的重载运算符。 基类的友元函数。 10.1.3 继承类型当一个类派生自基类，该基类可以被继承为 public、protected 或 private 几种类型。继承类型是通过上面讲解的访问修饰符 access-specifier 来指定的。 我们几乎不使用 protected 或 private 继承，通常使用 public 继承。当使用不同类型的继承时，遵循以下几个规则： 公有继承（public）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。 保护继承（protected）： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。 私有继承（private）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。 如下图所示： 基类 public 成员 基类 protected 成员 基类 private 成员 public 继承 public 成员 protected 成员 不能访问 protected 继承 protected 成员 protected 成员 不能访问 private 继承 private 成员 private 成员 不能访问 10.1.4 多继承多继承即一个子类可以有多个父类，它继承了多个父类的特性。 C++ 类可以从多个类继承成员，语法如下： 1234class &lt;派生类名&gt;:&lt;继承方式1&gt;&lt;基类名1&gt;,&lt;继承方式2&gt;&lt;基类名2&gt;,…{&lt;派生类类体&gt;}; 其中，访问修饰符继承方式是 public、protected 或 private 其中的一个，用来修饰每个基类，各个基类之间用逗号分隔，如上所示。 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt; using namespace std; // 基类 Shapeclass Shape { public: void setWidth(int w) { width = w; } void setHeight(int h) { height = h; } protected: int width; int height;}; // 基类 PaintCostclass PaintCost { public: int getCost(int area) { return area * 70; }}; // 派生类class Rectangle: public Shape, public PaintCost{ public: int getArea() { return (width * height); }}; int main(void){ Rectangle Rect; int area; Rect.setWidth(5); Rect.setHeight(7); area = Rect.getArea(); // 输出对象的面积 cout &lt;&lt; &quot;Total area: &quot; &lt;&lt; Rect.getArea() &lt;&lt; endl; // 输出总花费 cout &lt;&lt; &quot;Total paint cost: $&quot; &lt;&lt; Rect.getCost(area) &lt;&lt; endl; return 0;} 当上面的代码被编译和执行时，它会产生下列结果： 12Total area: 35Total paint cost: $2450 10.2 多态与虚函数10.2.1 多态多态按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。 C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。 如下例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt; using namespace std; class Shape { protected: int width, height; public: Shape( int a=0, int b=0) { width = a; height = b; } int area() { cout &lt;&lt; &quot;Parent class area :&quot; &lt;&lt;endl; return 0; }};class Rectangle: public Shape{ public: Rectangle( int a=0, int b=0):Shape(a, b) { } int area () { cout &lt;&lt; &quot;Rectangle class area :&quot; &lt;&lt;endl; return (width * height); }};class Triangle: public Shape{ public: Triangle( int a=0, int b=0):Shape(a, b) { } int area () { cout &lt;&lt; &quot;Triangle class area :&quot; &lt;&lt;endl; return (width * height / 2); }};// 程序的主函数int main( ){ Shape *shape; Rectangle rec(10,7); Triangle tri(10,5); // 存储矩形的地址 shape = &amp;rec; // 调用矩形的求面积函数 area shape-&gt;area(); // 存储三角形的地址 shape = &amp;tri; // 调用三角形的求面积函数 area shape-&gt;area(); return 0;} 当上面的代码被编译和执行时，它会产生下列结果： 12Parent class area :Parent class area : 导致错误输出的原因是，调用函数 area() 被编译器设置为基类中的版本，这就是所谓的静态多态，或静态链接 - 函数调用在程序执行前就准备好了。有时候这也被称为早绑定，因为 area() 函数在程序编译期间就已经设置好了。 但现在，让我们对程序稍作修改，在 Shape 类中，area() 的声明前放置关键字 virtual，如下所示： 123456789101112131415class Shape { protected: int width, height; public: Shape( int a=0, int b=0) { width = a; height = b; } virtual int area() { cout &lt;&lt; &quot;Parent class area :&quot; &lt;&lt;endl; return 0; }}; 修改后，当编译和执行前面的实例代码时，它会产生以下结果： 12Rectangle class area :Triangle class area : 此时，编译器看的是指针的内容，而不是它的类型。因此，由于 tri 和 rec 类的对象的地址存储在 *shape 中，所以会调用各自的 area() 函数。 正如您所看到的，每个子类都有一个函数 area() 的独立实现。这就是多态的一般使用方式。有了多态，您可以有多个不同的类，都带有同一个名称但具有不同实现的函数，函数的参数甚至可以是相同的。 10.2.2 虚函数 虚函数 是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。 我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。 pure virtual 函数： derived class 一定要重新定义 (override 覆写) 它；其没有定义只有声明 语法：virtual xxxxxx =0; = 0 告诉编译器，函数没有主体，上面的虚函数是纯虚函数。 virtual 函数： derived class 可以重新定义 (override, 覆写) 它，且它已有默认定义 语法：virtual xxxxxx; non-virtual 函数： 不希望 derived class 重新定义 (override, 覆写) 它","link":"/2024/07/07/C++/C-04/"},{"title":"侯捷C++面向对象编程下day5","text":"侯捷C++面向对象编程（下）课程打卡 侯捷C++面向对象编程（下）课程打卡 Day51 转换1.1 转换函数将当前对象的类型转换成其他类型 以operator开头，函数名称为需要转换的类型，无参数 前面无需写返回类型，编译器会自动根据函数名称进行补充 转换函数中，分子分母都没有改变，所有通常加const\\ 12345// class Fraction里的一个成员函数operator double() const{ return (double) (m_numerator / m_denominator);} 123Fraction f(3,5);double d = 4 + f; //编译器自动调用转换函数将f转换为0.6 1.2 non-explicit-one-argument ctor将其他类型的对象转换为当前类型 one-argument 表示只要一个实参就够了 123// non-explicit-one-argument ctorFraction(int num, int den = 1) : m_numerator(num), m_denominator(den) {} 12Fraction f(3,5);Fraction d = f + 4; //编译器调用ctor将4转化为Fraction 1.3 explicit当上面两个都有转换功能的函数在一起，编译器调用时都可以用，报错 12345678910111213141516171819202122class Fraction{public: Fraction(int num, int den = 1) : m_numerator(num), m_denominator(den) {} operator double() const { return (double)m_numerator / m_denominator; } Fraction operator+(const Fraction&amp; f) const { return Fraction(...); }private: int m_numerator; // 分子 int m_denominator; // 分母};... Fraction f(3,5);Fraction d = f + 4; // [Error] ambiguous one-argument ctor 加上 explicit，表示这个 ctor 只能在构造的时候使用，编译器不能拿来进行类型转换了 12345678...explicit Fraction(int num, int den = 1) : m_numerator(num), m_denominator(den) {}... Fraction f(3,5);Fraction d = f + 4; // [Error] 4不能从‘double’转化为‘Fraction’ 关键字 explicit 主要就在这里运用 2 xxx-like classes2.1 pointer-like classes2.1.1 智能指针 设计得像指针class，能有更多的功能，包着一个普通指针 指针允许的动作，这个类也要有，其中 *，-&gt; 一般都要重载 1234567891011template &lt;typename T&gt;class shared_ptr{public: T&amp; operator*() const { return *px; } T* operator-&gt;() const { return px; } shared_ptr(T* p) : ptr(p) {}private: T* px; long* pn;}; 在使用时，*shared_ptr1 就返回 *px； 但是 shared_ptr1-&gt; 得到的东西会继续用 -&gt; 作用上去，相当于这个-&gt;符号用了两次 2.1.2 迭代器以标准库中的链表迭代器为例，这种智能指针还需要处理 ++ -- 等符号 node是迭代器包着的一个真正的指针，其指向_list_node 下图 *ite 的意图是取 data——即一个 Foo 类型的 object 下图 ite-&gt;method 的意图是调用 Foo 中的函数 method 2.2 function-like classes设计一个class，行为像一个函数 函数行为即 —— xxx() 有一个小括号，所以函数中要有对 () 进行重载 12345678910111213141516171819template &lt;class pair&gt;struct select1st ... // 这里是继承奇特的Base classes，先不管{ const typename pair::first_type&amp; // 返回值类型，先不管 operator()(const pair&amp; x) const { return x.first; }};...//像一个函数一样在用这个类select1st&lt;my_pair&gt; selector;first_type first_element = selector(example_pair);//还可以这样写，第一个()在创建临时对象first_type first_element = select1st&lt;my_pair&gt;()(example_pair);... 3 模板3.1 类模板/函数模板补充：只有模板的尖括号中&lt;&gt;，关键字 typename 和 class 是一样的 3.2 成员模板它即是模板的一部分，自己又是模板，则称为成员模板 其经常用于构造函数 ctor1 这是默认构造函数的实现；它初始化 first 和 second 分别为 T1 和 T2 类型的默认构造函数生成的默认值 ctor2 这是带参数的构造函数的实现；它接受两个参数 a 和 b，并将它们分别用来初始化 first 和 second 成员变量 ctor3 这是一个==模板构造函数==，接受一个不同类型的 pair 对象作为参数；它允许从一个不同类型的 pair 对象构造当前类型的 pair 对象，在构造过程中，它将源 pair 对象的 first 和 second 成员变量分别赋值给当前对象的成员变量，使其具有一定的灵活性和通用性。 12345678910111213template &lt;class T1, class T2&gt;struct pair{ T1 first; T2 second; pair() : first(T1()), second(T2()) {} //ctor1 pair(const T1&amp; a, const T2&amp; b) : //ctor2 first(a), second(b) {} template &lt;class U1, class U2&gt; //ctor3 pair(const pair&lt;U1, U2&gt;&amp; p) : first(p.first), second(p.second) {}}; 例一，可以使用 &lt;鲫鱼，麻雀&gt; 对象来构造一个 &lt;鱼类，鸟类&gt; 的pair 例二，父类指针是可以指向子类的，叫做 up-cast；智能指针也必须可以，所以其构造函数需要为==模板构造函数== 3.3 模板模板参数即模板中的一个模板参数也为模板，下图黄色高亮部分 XCLs&lt;string, list&gt; mylist 中即表示：容器 list 是 string 类型的—— 创建一个 string 的链表；Container c; 即表示 list c; 但是这样 Container c; 语法过不了，容器 list 后面还有参数，需要用中间框和下面框下一行的代码 —— c++11的内容 注：下面不是模板模板参数 1class Sequence = deque&lt;T&gt;` 是有一个初始值，当没指定时就初始为 `deque&lt;T&gt; 在要指定时，如最后一行中的 list&lt;int&gt; 是确切的，不是模板","link":"/2024/07/07/C++/C-05/"},{"title":"侯捷C++面向对象编程下day6","text":"侯捷C++面向对象编程（下）课程打卡 侯捷C++面向对象编程（下）课程打卡 Day64. specialization 特化4.1 全特化 full specialization模板是泛化，特化是泛化的反面，可以针对不同的类型，来设计不同的东西 其语法为template&lt;&gt; struct xxx&lt;type&gt; 12345678910111213template&lt;&gt;struct hash&lt;char&gt;{... size_t operator()(char&amp; x) const {return x;}};template&lt;&gt;struct hash&lt;int&gt;{... size_t operator()(int&amp; x) const { return x; }}; 这里编译器就会用 int 的那段代码；注意：hash&lt;int&gt;() 是创建临时变量 1cout &lt;&lt; hash&lt;int&gt;()(1000) 4.2 偏特化 partial specialization4.2.1 个数上的偏例如：第一个模板参数我想针对 bool 特别设计 注意绑定模板参数不能跳着绑定，需要从左到右 4.2.2 范围上的偏例如：想要当模板参数是指针时特别设计 12C&lt;string&gt; obj1; //编译器会调用上面的C&lt;string*&gt; obj2; //编译器会调用下面的 5 三个C++11新特性5.1 variadic templates模板参数可变化，其语法为 ... (加在哪看情况) 123456789101112131415// 当参数pack里没有东西了就调用这个基本函数结束输出void print() {}// 用于打印多个参数的可变参数模板函数template &lt;typename T, typename... Args&gt;void print(const T&amp; first, const Args&amp;... args) { std::cout &lt;&lt; first &lt;&lt; &quot; &quot;; print(args...); // 使用剩余参数进行递归调用}int main() { print(1, &quot;Hello&quot;, 3.14, &quot;World&quot;); return 0;} 还可以使用 sizeof...(args) 来得到参数pack里的数量 5.2 auto编译器通过赋值的返回值类型，自动匹配返回类型 注：下面这样是不行的，第一行编译器找不到返回值类型 12auto ite; // errorite = find(c.begin(), c.end(), target); 5.3 ranged-base forfor 循环的新语法，for(声明变量 : 容器)，编译器会从容器中依次拿出数据赋值给声明变量中 12345678910for (decl : coll){ statement}//例for (int i : {1, 3, 4, 6, 8}) // {xx,xx,xx} 也是c++11的新特性{ cout &lt;&lt; i &lt;&lt; endl;} 注意：改变原容器中的值需要 pass by reference 1234567891011vector&lt;double&gt; vec;...for (auto elem : vec) //值传递{ cout &lt;&lt; elem &lt;&lt; endl;}for (auto&amp; elem : vec) //引用传递{ elem *= 3;} 6 多态 虚机制直接看链接吧 https://blog.csdn.net/WJwwwwwww/article/details/132268502 7 reference、const、new/delete7.1 referencex 是整数，占4字节；p 是指针占4字节（32位）；r 代表x，那么r也是整数，占4字节 123int x = 0;int* p = &amp;x; // 地址和指针是互通的int&amp; r = x; // 引用是代表x 引用与指针不同，只能代表一个变量，不能改变 引用底部的实现也是指针，但是注意 object 和它的 reference 的大小是相同的，地址也是相同的（是编译器制造的假象） 12sizeof(r) == sizeof(x)&amp;x == &amp;r reference 通常不用于声明变量，用于参数类型和返回类型的描述 以下 imag(const double&amp; im) 和 imag(const double im) 的签名signature 在C++中是视为相同的——二者不能同时存在 12double imag(const double&amp; im) /*const*/ {....}double imag(const double im){....} //Ambiguity 注意：const 是函数签名的一部分，所以加上后是可以共存的 7.2 constconst 加在函数后面 —— 常量成员函数（成员函数才有）：表示这个成员函数保证不改变 class 的 data const object non-const object const member function（保证不改变 data members） ✔️ ✔️ non-const member function（不保证 data members 不变） ❌ ✔️ COW：Copy On Write 多个指针共享一个 “Hello”；但当a要改变内容时， 系统会单独复制一份出来给a来改，即 COW 在常量成员函数中，数据不能被改变所以不需要COW；而非常量成员函数中数据就有可能被改变，需要COW 1234567891011charToperator[] (size_type pos)const{ .... /* 不必考虑COW */ }referenceoperator[] (size_type pos){ .... /* 必须考虑COW */} 函数签名不包括返回类型但包括const，所以上面两个函数是共存的 当两个版本同时存在时，*const object* 只能调用 *const* 版本，*non-const object* 只能调用 *non-const* 版本 7.3 new delete 7.3.1 全局重载 可以全局重载 operator new、operator delete、operator new[]、operator delete[] 这几个函数是在 new 的时候，编译器的分解步骤中的函数，是给编译器调用的 注意这个影响非常大！ 1234inline void* operator new(size_t size){....}inline void* operator new[](size_t size){....}inline void operator delete(void* ptr){....}inline void operator delete[](void* ptr){....} 7.3.2 class中成员重载 可以重载 class 中成员函数 operator new、operator delete、operator new[]、operator delete[] 重载之后，new 这个类时，编译器会使用重载之后的 12345678910class Foo{public： void* operator new(size_t size){....} void operator delete(void* ptr, size_t size){....} // size_t可有可无 void* operator new[](size_t size){....} void operator delete[](void* ptr, size_t size){....} // size_t可有可无 ....} 1234567// 这里优先调用 members，若无就调用 globalsFoo* pf = new Foo;delete pf;// 这里强制调用 globalsFoo* pf = ::new Foo;::delete pf; 7.3.3 placement new delete可以重载 class 成员函数 placement new operator new()，可以写出多个版本，前提是每一个版本的声明有独特的传入参数列，且其中第一个参数必须是 size_t，其余参数出现于 new(.....) 小括号内（即 placement arguments） 123Foo* pf = new(300, 'c') Foo; // 其中第一个参数size_t不用写// 对应的operator newvoid* operator new (size_t size, long extra, char init){....} 我们也可以重载对应的 class 成员函数 operator delete()，但其不会被delete调用，只当 new 调用的构造函数抛出异常 exception 的时候，才会调用来归还未能完全创建成功的 object 占用的内存","link":"/2024/07/07/C++/C-06/"},{"title":"STL学习打卡Day01","text":"STL学习 一、vector1.1 介绍vector为可变长数组（动态数组），定义的vector数组可以随时添加数值和删除元素。 注意：在局部区域中（比如局部函数里面）开vector数组，是在堆空间里开的。 在局部区域开数组是在栈空间开的，而栈空间比较小，如果开了非常长的数组就会发生爆栈。故局部数组不可以开大长度数组，但是可以开大长度vector. 头文件 1#include &lt;vector&gt; 一维初始化 123vector&lt;int&gt; a;//定义了一个名为a的一维数组，数组存储int类型的数据vector&lt;double&gt; b;//定义了一个名叫b的一维数组，数组存储double类型的数据vector&lt;node&gt; c;//定义了一个名为c的一维数组，数组存储结构体类型数据，node是结构体类型 指定长度和初始值的初始化： 123vector&lt;int&gt; v(n);//定义一个长度为n的数组，初始值默认为0，下标范围为[0,n-1]vector&lt;int&gt; v(n,1);// v[0] 到 v[n - 1]所有的元素初始值均为1//注意：指定数组长度之后（指定长度后的数组就相当于正常的数组了） 初始化中有多个元素： 1vector&lt;int&gt; a{1,2,3,4,5};//数组a中有五个元素，数组长度为5 拷贝初始化： 123vextor&lt;int&gt; a(n+1,0);vector&lt;int&gt; b(a);//两个数组中的类型必须相同，a和b都是长度为n+1,初始值为0的数组vector&lt;int&gt; c = a;//也是拷贝初始化，c和a是完全一样的数组。 二维初始化 定义第一维固定长度为5，第二维可变化的二维数组： 123vector&lt;int&gt; v[5]//定义可变长二维数组//注意：行不可变（只有5行）, 而列可变,可以在指定行添加元素//第一维固定长度为5，第二维长度可以改变 vector&lt;int&gt; v[5]可以这样理解：长度为5的v数组，数组中存储的是vector&lt;int&gt; 数据类型，而该类型就是数组形式，故v为二维数组。其中每个数组元素均为空，因为没有指定长度，所以第二维可变长。可以进行下述操作： 12v[1].push_back(2);v[2].push_back(3); 行列均可变： 12//初始化二维均可变长数组vector&lt;vector&lt;int&gt;&gt; v;//定义一个行和列均可变的二维数组 应用：可以在v数组中装入多个数组： 12345vector&lt;int&gt; t1{1, 2, 3, 4};vector&lt;int&gt; t2{2, 3, 4, 5};v.push_back(t1);v.push_back(t2);v.push_back({3, 4, 5, 6}) // {3, 4, 5, 6}可以作为vector的初始化,相当于一个无名vector 行列长度均固定n+1行m+1列初始值为0： 1vector&lt;vector&lt;int&gt;&gt; a(n + 1, vector&lt;int&gt;(m + 1, 0)); c++17或者c++20支持的形式（不常用），与上面相同的初始化 1vector a(n + 1, vector(m + 1, 0)); 1.2 方法函数知道了如何定义初始化可变数组，下面就要知道如何添加、删除、修改数据。 c指定为数组名称，含义中会注明算法复杂度。 代码 含义 c.front() 返回第一个数据O(1) c.back 返回最后一个数据O(1) c.pop_back() 删除最后一个数据O(1) c.push_back(element) 在尾部添加一个数据O(1) c.size() 返回实际数据个数(unsigned类型)O(1) c.clear() 清除元素个数O(N),N为元素个数 c.resize(n,v) 改变数组大小为n，n个空间数值赋为v，如果没有默认值为0 c.insert(it,x) 向任意迭代器it插入一个元素x，O(N) 例：c.insert(c.begin() + 2,-1) 将-1插入c[2]的位置 c.erase(first,last) 删除[first,last]的所有元素，O(N) c.begin() 返回首元素的迭代器(通俗的来说就是地址),O(N) c.end() 返回最后一个元素后一个位置的迭代器,O(1) c.empty() 判断是否为空，为空则返回真，反之则返回假,O(1) 注意： end()返回的是最后一个元素的后一个位置的地址，不是最后一个元素的地址，所有STL容器均是如此 使用vi.resize(n,v)函数时，若vi之前指定过大小为pre pre&gt;n：即数组大小变小了，数组会保存前n个元素，前n个元素值为原来的值，不是都为v pre&lt;n：即数组大小变大了，数组会在后面插入n-pre个值为v的元素 也就是说，这个初始值v只对新插入的元素有效。 123456789101112#include&lt;bits/stdc++.h&gt;using namespace std;void out(vector&lt;int&gt; &amp;a) { for (auto &amp;x: a) cout &lt;&lt; x &lt;&lt; &quot; &quot;; cout &lt;&lt; &quot;\\n&quot;; }int main() { vector&lt;int&gt; a(5, 1); out(a); // 1 1 1 1 1 a.resize(10, 2); out(a); // 1 1 1 1 1 2 2 2 2 2 a.resize(3, 3); out(a); // 1 1 1 return 0;} 排序 使用sort排序要：sort(c.begin(),c.end()); 对所有元素进行排序，如果要对指定区间进行排序，可以对sort()里面的参数进行加减改动。 12vector&lt;int&gt; a(n + 1);sort(a.begin() + 1, a.end()); // 对[1, n]区间进行从小到大排序 1.3 访问共三种方法： 下标法：和普通数组一样 注意：一维数组的下标是从0到v.size()-1，访问之外的数回出现越界错误 迭代器法：类似指针一样的访问，首先需要声明迭代器变量，和声明指针变量一样，可以根据代码进行理解。 123vector&lt;int&gt; vi; //定义一个vi数组vector&lt;int&gt;::iterator it = vi.begin();//声明一个迭代器指向vi的初始位置 使用auto ：非常简便，但是会访问数组的所有元素（特别注意0位置元素也会访问到） 1.3.1 下标访问直接和普通数组一样访问就行。 12345678//添加元素for(int i = 0; i &lt; 5; i++) vi.push_back(i); //下标访问 for(int i = 0; i &lt; 5; i++) cout &lt;&lt; vi[i] &lt;&lt; &quot; &quot;;cout &lt;&lt; &quot;\\n&quot;; 1.3.2 迭代器访问类似指针，迭代器就是充当指针的作用。 12345vector&lt;int&gt; vi{1, 2, 3, 4, 5};//迭代器访问vector&lt;int&gt;::iterator it; // 相当于声明了一个迭代器类型的变量it// 通俗来说就是声明了一个指针变量 方式一： 1234vector&lt;int&gt;::iterator it = vi.begin(); for(int i = 0; i &lt; 5; i++) cout &lt;&lt; *(it + i) &lt;&lt; &quot; &quot;;cout &lt;&lt; &quot;\\n&quot;; 方式二： 1234567891011vector&lt;int&gt;::iterator it;for(it = vi.begin(); it != vi.end();it ++) cout &lt;&lt; *it &lt;&lt; &quot; &quot;;//vi.end()指向尾元素地址的下一个地址// 或者auto it = vi.begin();while (it != vi.end()) { cout &lt;&lt; *it &lt;&lt; &quot;\\n&quot;; it++;} 1.3.3 智能指针只能遍历完数组，如果要指定的内容进行遍历，需要另行选择方法。 auto 能够自动识别并获取类型。 123456789101112// 1. 输入vector&lt;int&gt; a(n);for (auto &amp;x: a) { cin &gt;&gt; x; // 可以进行输入，注意加引用}// 2. 输出vector&lt;int&gt; v;v.push_back(12);v.push_back(241);for(auto val : v) { cout &lt;&lt; val &lt;&lt; &quot; &quot;; // 12 241} vector注意： vi[i] 和 *(vi.begin() + i) 等价，与指针类似。 vector和string的STL容器支持*(it + i)的元素访问，其它容器可能也可以支持这种方式访问，但用的不多，可自行尝试。","link":"/2024/07/07/C++/STL01/"},{"title":"STL学习打卡Day02","text":"STL学习 二、Stack2.1 介绍栈作为数据结构中的一种，是STL实现的一个先进先出，后进后出的容器。 1234567//头文件添加#include&lt;stack&gt;//声明stack&lt;int&gt; s;stack&lt;string&gt; s;stack&lt;node&gt; s;//node是结构体类型 2.2 方法函数 代码 含义 s.push(ele) 元素ele入列，增加元素O(1) s.pop() 移出栈顶元素O(1) s.top() 取得栈顶元素（但是不删除）O(1) s.empty() 检测栈内是否为空，空为真O(1) s.size() 返回栈内元素个数O(1) 2.3 栈遍历2.3.1 栈遍历栈只能对栈顶元素进行操作，如果想要进行遍历，只能将栈中元素一个个取出来存在数组中 123456stack&lt;int&gt; st;for (int i = 0; i &lt; 10; ++i) st.push(i);while (!st.empty()) { int tp = st.top(); // 栈顶元素 st.pop();} 2.3.2 数组模拟栈进行遍历通过一个数组对栈进行模拟，一个存放下标的变量top模拟指向栈顶的指针。 一般来说单调栈和单调队列写法均可以使用额外变量tt或者hh来进行模拟 特点：比STL的stack速度更快，遍历元素方便 12345678910111213141516int s[100]; // 栈 从左至右为栈底到栈顶int tt = -1; // tt 代表栈顶指针,初始栈内无元素，tt为-1for(int i = 0; i &lt;= 5; ++i) { //入栈 s[++tt] = i;}// 出栈int top_element = s[tt--]; //入栈操作示意// 0 1 2 3 4 5 // tt//出栈后示意// 0 1 2 3 4 // tt","link":"/2024/07/08/C++/STL02/"},{"title":"STL学习打卡Day03","text":"STL学习 三、queue3.1 介绍队列是一种先进先出的数据结构。 1234//头文件#include&lt;queue&gt;//定义初始化queue&lt;int&gt; q; 3.2 方法函数 代码 含义 q.front() 返回队首元素O(1) q.back() 返回队尾元素，O(1) q.push(element) 尾部添加一个元素element进队O(1) q.pop() 删除第一个元素 出队O(1) q.size() 返回队列中元素个数，返回值unsigned int，O(1) q.empty() 判断是否为空，队列为空，返回true,O(1) 3.3 队列模拟使用**q[]**数组模拟队列 hh表示队首元素的下标，初始值为0 tt表示队尾元素的下标，初始值为-1，表示刚开始队列为空 一般来说单调栈和单调队列写法均可使用额外变量tt或hh来进行模拟 12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 +5;int q[N];int main(){ int hh = 0,tt = -1; //入队 q[++tt] = 1; q[++tt] = 2; //将所有元素出队 while(hh &lt;= tt){ int t = q[hh++]; printf(&quot;%d&quot;,t); } return 0;} 3.4 队列模拟例题题目链接： https://atcoder.jp/contests/abc247/tasks/abc247_d 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;using ll = long long ;using pii = pair&lt;int, int&gt;;const int N = 250005, mod = 998244353;int q[N], num[N];void solve() { int qq, hh = 0, tt = -1; cin &gt;&gt; qq; while(qq--) { int op; cin &gt;&gt; op; int x, c; if(op == 1) { cin &gt;&gt; x &gt;&gt; c; q[++tt] = c; num[tt] = x; } else { cin &gt;&gt; c; ll res = 0; while(c) { if(q[hh] &gt; c) { q[hh] -= c; res += 1ll * c * num[hh]; break; } else { res += 1ll * q[hh] * num[hh]; c -= q[hh++]; } } cout &lt;&lt; res &lt;&lt; &quot;\\n&quot;; } }}int main() { ios::sync_with_stdio(false); cin.tie(0); int t; // cin &gt;&gt; t; t = 1; while(t--) solve(); return 0;} 四、deque4.1 介绍首尾都可以插入和删除的队列为双端队列。 1234//添加头文件#include&lt;deque&gt;//初始化定义deque&lt;int&gt; dq; 4.2 方法函数1注意双端队列的常数比较大。 代码 含义 push_back(x)/push_front(x) 将x插入队尾后/队首O(1) back()/front() 返回队尾/队首元素O(1) pop_back()/pop_front() 删除队尾/队首元素 O(1) erase(iterator it) 删除双端队列中的某一个元素 erase(iterator first,iterator last) 删除双端队列中[first,last)中的元素 empty() 判断deque是否为空,O(1) size() 返回deque的元素数量O(1) clear() 清空deque 4.3 注意点deque可以进行排序 双端队列排序一般不用，感觉毫无用处，使用其他STL仍然可以实现相似的功能 12345//从小到大sort(q.begin(), q.end())//从大到小排序sort(q.begin(), q.end(), greater&lt;int&gt;());//deque里面的类型需要是int型sort(q.begin(), q.end(), greater());//高版本C++才可以用 五、priority_queue5.1 介绍优先队列是在正常队列的基础上加了优先级，保证每次的队首元素都是优先级最大的。 可以实现每次从优先队列中取出的元素都是队列中优先级最大的一个。 它的底层是通过堆来实现的。 1234//头文件#include&lt;queue&gt;//初始化定义priority_queue&lt;int&gt; q; 5.2 函数方法 代码 含义 q.top() 访问队首元素O(1) q.push() 入队，O(logN) q.pop() 堆顶（队首）元素出队O(logN) q.size() 队列元素个数O(1) q.empty() 是否为空O(1) 注意：没有clear()! 不提供该方法 优先队列只能通过top()访问队首元素（优先级最高的元素） 5.3 设置优先级5.3.1 基本数据类型的优先级12priority_queue&lt;int&gt; pq;//默认大根堆，即每次取出的元素是队列中的最大值priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; q;//小根堆，每次取出的元素是队列中的最小值 参数解释： 第一个参数：就是优先队列中存储的数据类型 第二个参数： vector是用来承载底层数据结构堆的容器，若优先队列中存放的是double型数据，就要填vector 总之存的是什么类型的数据，就相应的填写对应的类型，同时也要改动第三个参数里面的对应类型。 第三个参数： less表示数字大的优先级大，堆顶为最大的数字 greater表示数字小的优先级大，堆顶为最小的数字 int代表的是数据类型，也要填优先队列中存储的数据类型。 下面介绍基础数据类型优先级设置的写法： 基础写法（常用） 1234priority_queue&lt;int&gt; q1; // 默认大根堆, 即每次取出的元素是队列中的最大值priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; q2; // 大根堆, 每次取出的元素是队列中的最大值，同第一行priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q3; // 小根堆, 每次取出的元素是队列中的最小值 自定义排序（不常见，主要是书写麻烦） 123456789101112struct cmp1 { bool operator()(int x, int y) { return x &gt; y; }};struct cmp2 { bool operator()(const int x, const int y) { return x &lt; y; }};priority_queue&lt;int, vector&lt;int&gt;, cmp1&gt; q1; // 小根堆priority_queue&lt;int, vector&lt;int&gt;, cmp2&gt; q2; // 大根堆 5.3.2 高级数据类型（结构体）优先级即优先队列中存储结构体类型，必须要设置优先级，即结构体的比较运算（因为优先队列的堆中要比较大小，才能将对应最大或者最小元素移到堆顶） 优先级设计可以定义在结构体内进行小小于号重载，也可以定义在结构体外 1234//要排序的结构体（存储在优先队列里面的）struct Point{int x,y;}; 版本一：自定义全局比较规则 123456789//定义的比较结构体//注意：cmp是个结构体struct cmp{//自定义堆的排序规则 bool operator()(const Point&amp; a,const Point&amp; B=b){ return a.x &lt; b.x; }};//初始化定义priority_queue&lt;Point,vector&lt;Point&gt;,cmp&gt; q;//x大的在堆顶 版本二：直接在结构体里面写 因为是在结构体内部自定义的规则，一但需要比较结构体，自动调用结构体内部重载运算符规则 结构体内部有两种方式： 方式一： 123456struct node{ int x, y; friend bool operator&lt;(Point a, Point b){//为两个结构体参数，结构体调用一定要写上friend return a.x &lt; b.x;//按x从小到大排，x大的在堆顶 }} 方法二：（推荐） 123456struct node { int x, y; bool operator &lt; (const Point &amp;a) const {//直接传入一个参数，不必要写friend return x &lt; a.x;//按x升序排列，x大的在堆顶 }}; 优先队列的定义： 1priority_queue&lt;Point&gt; q; 注意：优先级队列自定义排序规则和sort()函数定义cmp函数很相似，但是最后返回的情况是相反的。即相同的符号，最后定义的排序顺序是完全相反的。 所以只要记住sort的排序规则和优先队列的排序规则是相反的就可以了。 当理解了堆的原理就会发现，堆调整时比较顺序是孩子和父亲节点进行比较，如果是 &gt; ，那么孩子节点要大于父亲节点，堆顶自然是最小值。 5.4 存储特殊类型的优先级5.4.1 存储pair类型 排序规则： 默认对pair的first进行降序排序，然后对second降序排序 对first先排序，大的排在前面，如果first元素相同，再对second元素排序，保持大的在前面。 1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;int main() { priority_queue&lt;pair&lt;int, int&gt; &gt;q; q.push({7, 8}); q.push({7, 9}); q.push(make_pair(8, 7)); while(!q.empty()) { cout &lt;&lt; q.top().first &lt;&lt; &quot; &quot; &lt;&lt; q.top().second &lt;&lt; &quot;\\n&quot;; q.pop(); } return 0;}结果：8 77 97 8","link":"/2024/07/08/C++/STL03/"},{"title":"STL学习打卡Day04","text":"STL学习 六、map6.1 介绍映射类似于函数的对应关系，每一个x对应一个y,而map是每个键对应一个值。和python的字典非常相似。 123456//头文件#include&lt;map&gt;//初始化定义map&lt;string,string&gt; mp;map&lt;string,int&gt; mp;map&lt;int,node&gt; mp;//node是结构体类型 map特性：map会按照键的顺序从小到大自动排序，键的类型必须可以比较大小 6.2 函数方法6.2.1 函数方法 代码 含义 mp.find(key) 返回值为key的映射的迭代器。O(logN)。注意：用find函数来定位数据出现的位置，它返回一个迭代器。当数据存在时，返回数据所在位置的迭代器，数据不存在时，返回map.end() map.erase(it) 删除迭代器对应的键和值O(1) mp.erase(key) 根据映射的键删除键和值O(logN) mp.erase(first,last) 删除左闭右开区间迭代器对应的键和值O(last−first) mp.size() 返回映射的对数O(1) mp.clear() 清空map中的所有元素O ( N ) mp.insert() 插入元素，插入时要构造键值对 mp.empty() 如果map为空，返回true，否则返回false mp.begin() 返回指向map第一个元素的迭代器（地址） mp.end() 返回指向map尾部的迭代器（最后一个元素的下一个地址） mp.rbegin() 返回指向map最后一个元素的迭代器（地址） mp.rend() 返回指向map第一个元素前面(上一个）的逆向迭代器（地址） mp.count(key) 查看元素是否存在，因为map中键是唯一的，所以存在返回1，不存在返回0 mp.lower_bound() 返回一个迭代器，指向键值&gt;= key的第一个元素 mp.upper_bound() 返回一个迭代器，指向键值&gt; key的第一个元素 6.2.2 注意点下面说明部分函数方法的注意点 注意：查找元素是否存在时，可以使用①mp.find() ② mp.count() ③ mp[key]但是第三种情况，如果不存在对应的key时，会自动创建一个键值对（产生一个额外的键值对空间）所以为了不增加额外的空间负担，最好使用前两种方法 6.2.3 迭代器进行正反向遍历 mp.begin()和mp.end()用法： 用于正向遍历map 123456789map&lt;int,int&gt; mp;mp[1] = 2;mp[2] = 3;mp[3] = 4;auto it = mp.begin();while(it != mp.end()) { cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; &quot;\\n&quot;; it ++;} 结果： 1231 22 33 4 mp.rbegin()和mp.rend() 用于逆向遍历map: 123456789map&lt;int,int&gt; mp;mp[1] = 2;mp[2] = 3;mp[3] = 4;auto it = mp.rbegin();while(it != mp.rend()) { cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; &quot;\\n&quot;; it ++;} 结果： 1233 42 31 2 6.2.4 二分查找二分查找lower_bound() upper_bound() map的二分查找以第一个元素（即键为准），对键进行二分查找返回值为map迭代器类型 1234567891011#include&lt;bits/stdc++.h&gt;using namespace std;int main() { map&lt;int, int&gt; m{{1, 2}, {2, 2}, {1, 2}, {8, 2}, {6, 2}};//有序 map&lt;int, int&gt;::iterator it1 = m.lower_bound(2); cout &lt;&lt; it1-&gt;first &lt;&lt; &quot;\\n&quot;;//it1-&gt;first=2 map&lt;int, int&gt;::iterator it2 = m.upper_bound(2); cout &lt;&lt; it2-&gt;first &lt;&lt; &quot;\\n&quot;;//it2-&gt;first=6 return 0;} 6.3 添加元素12//先声明map&lt;string, string&gt; mp; 方式一： 12mp[&quot;学习&quot;] = &quot;看书&quot;;mp[&quot;玩耍&quot;] = &quot;打游戏&quot;; 方式二：插入元素构造键值对 1mp.insert(make_pair(&quot;vegetable&quot;,&quot;蔬菜&quot;)); 方式三： 1mp.insert(pair&lt;string,string&gt;(&quot;fruit&quot;,&quot;水果&quot;)); 方式四: 1mp.insert({&quot;hahaha&quot;,&quot;wawawa&quot;}); 6.4 访问元素6.4.1 下标访问(大部分情况用于访问单个元素) 12mp[&quot;菜哇菜&quot;] = &quot;强哇强&quot;;cout &lt;&lt; mp[&quot;菜哇菜&quot;] &lt;&lt; &quot;\\n&quot;;//只是简写的一个例子，程序并不完整 6.4.2 遍历访问 方式一：迭代器访问 12345678map&lt;string,string&gt;::iterator it;for(it = mp.begin(); it != mp.end(); it++) { // 键 值 // it是结构体指针访问所以要用 -&gt; 访问 cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; &quot;\\n&quot;; //*it是结构体变量 访问要用 . 访问 //cout&lt;&lt;(*it).first&lt;&lt;&quot; &quot;&lt;&lt;(*it).second;} 方式二：智能指针访问 12for(auto i : mp)cout &lt;&lt; i.first &lt;&lt; &quot; &quot; &lt;&lt; i.second &lt;&lt; endl;//键，值 方式三：对指定单个元素访问 12map&lt;char,int&gt;::iterator it = mp.find('a');cout &lt;&lt; it -&gt; first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; &quot;\\n&quot;; 方式四：c++17特性才具有 123for(auto [x, y] : mp) cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot;\\n&quot;;//x,y对应键和值 6.5 与unordered_map的比较这里就不单开一个大目录讲unordered_map了，直接在map里面讲了。 6.5.1 内部实现原理map：内部用红黑树实现，具有自动排序（按键从小到大）功能。 unordered_map：内部用哈希表实现，内部元素无序杂乱。 6.5.2 效率比较map： 优点：内部用红黑树实现，内部元素具有有序性，查询删除等操作复杂度为O ( l o g N ) O(logN)O(logN) 缺点：占用空间，红黑树里每个节点需要保存父子节点和红黑性质等信息，空间占用较大。 unordered_map： 优点：内部用哈希表实现，查找速度非常快（适用于大量的查询操作）。 缺点：建立哈希表比较耗时。 两者方法函数基本一样，差别不大。 注意： 随着内部元素越来越多，两种容器的插入删除查询操作的时间都会逐渐变大，效率逐渐变低。 使用[]查找元素时，如果元素不存在，两种容器都是创建一个空的元素；如果存在，会正常索引对应的值。所以如果查询过多的不存在的元素值，容器内部会创建大量的空的键值对，后续查询创建删除效率会大大降低。 查询容器内部元素的最优方法是：先判断存在与否，再索引对应值（适用于这两种容器） 12345// 以 map 为例map&lt;int, int&gt; mp;int x = 999999999;if(mp.count(x)) // 此处判断是否存在x这个键 cout &lt;&lt; mp[x] &lt;&lt; &quot;\\n&quot;; // 只有存在才会索引对应的值，避免不存在x时多余空元素的创建 另外： 还有一种映射：multimap 键可以重复，即一个键对应多个值，如要了解，可以自行搜索。 七 、set7.1 介绍set容器中的元素不会重复，当插入集合中已有的元素时，并不会插入进去，而且set容器里的元素自动从小到大排序。 即：set里面的元素不重复且有序 1234//头文件#include&lt;set&gt;//初始化定义set&lt;int&gt; s; 7.2 函数方法 代码 含义 s.begin() 返回set容器的第一个元素的地址（迭代器）O(1) s.end() 返回set容器的最后一个元素的下一个地址（迭代器）O(1) s.rbegin() 返回逆序迭代器，指向容器元素的最后一个位置O(1) s.rend() 返回逆序迭代器吗，指向容器第一个元素前面的位置O(1) s.clear() 删除set容器中的所有的元素，返回unsigned int类型O(N) s.empty() 判断set容器是否为空O(1) s.insert() 插入一个元素 s.size() 返回当前set容器中的元素个数O(1) erase(inerator) 删除定位器iterator指向的值 erase(first,second) 删除定位器first和second之间的值 erase(key_value) 删除键值key_value的值 s.find(element) 查找set中的某一个元素，有则返回该元素对应的迭代器，无则返回结束迭代器 s.count(element) 查找set中的元素出现的个数，由于set中元素唯一，此函数相当于直接询问element是否出现 s.lower_bound(k) 返回大于等于k的第一个元素的迭代器O(logN) s.upper_bound(k) 返回大于k的第一个元素的迭代器O(logN) 7.3 访问 迭代器访问 12for(set&lt;int&gt;::iterator it = s.begin();it!=s.end();it++) cout &lt;&lt; *it &lt;&lt; &quot; &quot;; 智能指针 12for (auto i : s) cout &lt;&lt; i &lt;&lt; endl; 访问最后一个元素 12//第一种cout &lt;&lt; *s.rbegin() &lt;&lt; endl; 1234//第二种set&lt;int&gt;::iterator iter = s.end();iter--;cout &lt;&lt; (*iter) &lt;&lt; endl; //打印2; 12//第三种cout &lt;&lt; *(--s.end()) &lt;&lt; endl; 7.4 重载&lt;运算符 基础数据类型 方式一：改变set排序规则，set中默认使用less比较器，即从小到大排序。（常用） 12set&lt;int&gt; s1; // 默认从小到大排序set&lt;int, greater&lt;int&gt; &gt; s2; // 从大到小排序 方式二：重载运算符。（很麻烦，不太常用，没必要） 1234567891011121314//重载 &lt; 运算符struct cmp { bool operator () (const int&amp; u, const int&amp; v) const { // return + 返回条件 return u &gt; v; }};set&lt;int, cmp&gt; s; for(int i = 1; i &lt;= 10; i++) s.insert(i);for(auto i : s) cout &lt;&lt; i &lt;&lt; &quot; &quot;;// 10 9 8 7 6 5 4 3 2 1 方式三：初始化时使用匿名函数定义比较规则 1234567set&lt;int, function&lt;bool(int, int)&gt;&gt; s([&amp;](int i, int j){ return i &gt; j; // 从大到小});for(int i = 1; i &lt;= 10; i++) s.insert(i);for(auto x : s) cout &lt;&lt; x &lt;&lt; &quot; &quot;; 高级数据结构（结构体） 直接重载结构体运算符即可，让结构体可以比较。 12345678910111213141516171819202122232425262728293031323334struct Point { int x, y; bool operator &lt; (const Point &amp;p) const { // 按照点的横坐标从小到大排序,如果横坐标相同,纵坐标从小到大 if(x == p.x) return y &lt; p.y; return x &lt; p.x; }};set&lt;Point&gt; s;for(int i = 1; i &lt;= 5; i++) { int x, y; cin &gt;&gt; x &gt;&gt; y; s.insert({x, y});} /* 输入5 45 23 73 54 8*/for(auto i : s) cout &lt;&lt; i.x &lt;&lt; &quot; &quot; &lt;&lt; i.y &lt;&lt; &quot;\\n&quot;;/* 输出3 53 74 85 25 4*/ 7.5 其他setmultiset:元素可以重复，且元素有序 unordered_set ：元素无序且只能出现一次 unordered_multiset ： 元素无序可以出现多次 八、 pair8.1 介绍pair只含有两个元素，可以看作是只有两个元素的结构体 应用： 代替二元结构体 作为map键值对进行插入（代码如下） 1234map&lt;string, int&gt; mp;mp.insert(pair&lt;string, int&gt;(&quot;xingmaqi&quot;,1));// mp.insert(make_pair(&quot;xingmaqi&quot;, 1));// mp.insert({&quot;xingmaqi&quot;, 1}); 初始化和赋值操作： 1234567891011//头文件#include&lt;utility&gt;//1.初始化定义pair&lt;string,int&gt; p(&quot;cailiangwei&quot;,1);//带初始值的pair&lt;string,int&gt; p ;//不带初始值的//2.赋值p = {&quot;cai&quot;,18};p = make_pair(&quot;wang&quot;, 18);p = pair&lt;string, int&gt;(&quot;wang&quot;, 18); 8.2 访问123456//定义结构体数组pair&lt;int,int&gt; p[20];for(int i = 0;i &lt; 20; i++){ //和结构体相似，first代表第一个元素，second表示第二个元素 cout &lt;&lt; p[i].first &lt;&lt; &quot; &quot; &lt;&lt; p[i].second;}","link":"/2024/07/09/C++/STL04/"},{"title":"STL学习打卡Day05","text":"STL学习 九、string9.1 介绍string是一个字符串类，和char型字符串类似。 可以把string理解为一个字符串类型，像int一样可以定义。 9.2 初始化及定义123456789101112131415//头文件#include&lt;string&gt;//1.string str1;//生成空字符串//2.string str2(&quot;123456789&quot;);//生成&quot;123456789&quot;的复制品//3.string str3(&quot;12345&quot;.0,3);//结果为&quot;123&quot;,从0开始，长度为3//4.string str4(&quot;12345&quot;,5);//结果为&quot;12345&quot;,长度为5//5.string str5(5,'2');//结果为&quot;22222&quot;,构造5个字符'2'连接成的字符串//6.string str6(str2,2);//结果为&quot;3456789&quot;,截取第三个元素(2对应第三位)到最后 简单使用 访问单个字符： 123456789#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main() { string s = &quot;xing ma qi!!!&quot;; for(int i = 0; i &lt; s.size(); i++) cout &lt;&lt; s[i] &lt;&lt; &quot; &quot;; return 0;} string数组使用： 1234567891011#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main() { string s[10]; for(int i = 1; i &lt; 10; i++) { s[i] = &quot;loading... &quot; ; cout &lt;&lt; s[i] &lt;&lt; i &lt;&lt; &quot;\\n&quot;; } return 0;} 结果： 123456789loading... 1loading... 2loading... 3loading... 4loading... 5loading... 6loading... 7loading... 8loading... 9 9.3 string特性 支持比较运算符 string字符串支持常见的比较操作符（&gt;,&gt;=,&lt;,&lt;=,==,!=），支持string与C-string的比较（如 str &lt; “hello”）。在使用&gt;,&gt;=,&lt;,&lt;=这些操作符的时候是根据“当前字符特性”将字符按 字典顺序 进行逐一得 比较。字典排序靠前的字符小， 比较的顺序是从前向后比较，遇到不相等的字符就按这个位置上的两个字符的比较结果确定两个字符串的大小（前面减后面）。 同时，string (“aaaa”) &lt;string(aaaaa)。 支持+运算符，代表拼接字符串string字符串可以拼接，通过”+”运算符进行拼接。 1234string s1 = &quot;123&quot;;string s2 = &quot;456&quot;;string s = s1 + s2;cout &lt;&lt; s; //123456 9.4 读入详解读入字符串，遇空格，回车结束 12string s;cin &gt;&gt; s; 读入一行字符串（包括空格），遇回车结束 12string s;getline(cin, s); 注意: getline(cin, s)会获取前一个输入的换行符，需要在前面添加读取换行符的语句。如：getchar() 或 cin.get() 错误读取： 1234int n;string s;cin &gt;&gt; n;getline(cin, s); //此时读取相当于读取了前一个回车字符 正确读取: 12345int n;string s;cin &gt;&gt; n;getchar(); //cin.get()getline(cin, s);//可正确读入下一行的输入 cin与cin.getline()混用 cin输入完后，回车，cin遇到回车结束输入，但回车还在输入流中，cin并不会清除，导致getline()读取回车，结束。需要在cin后面加cin.ignore()；主动删除输入流中的换行符。（不常用） cin和cout解锁 代码（写在main函数开头）： 12ios::sync_with_stdio(false);cin.tie(0),cout.tie(0); 为什么要进行cin和cout的解锁，原因是： 在一些题目中，读入的数据量很大，往往超过了1e5（105）的数据量,而cin和cout的读入输出的速度很慢（是因为cin和cout为了兼容C语言的读入输出在性能上做了妥协），远不如scanf和printf的速度，具体原因可以搜索相关的博客进行了解。 所以对cin和cout进行解锁使cin和cout的速度几乎接近scanf和printf，避免输入输出超时。 注意：cin cout解锁使用时，不能与 scanf,getchar, printf,cin.getline()混用，一定要注意，会出错。 string于C语言字符串(C-string)的区别： string是C++的一个类，专门实现字符串的相关操作。具有丰富的操作方法，数据类型为string，字符串结尾没有\\0字符 C-stringC语言中的字符串，用char数组实现，类型为const char *,字符串结尾以\\0结尾 一般来说string向char数组转换会出现一些问题，所以为了能够实现转换，string有一个方法c_str()实现string向char数组的转换。 12string s = &quot;xing ma qi&quot;;const char *s2 = s.c_str(); 9.5 函数方法 获取字符串长度 代码 含义 s.size()和s.length() 返回string对象的字符个数，他们执行效果相同。 s.max_size() 返回string对象最多包含的字符数，超出会抛出length_error异常 s.capacity() 重新分配内存之前，string对象能包含的最大字符数 插入 代码 含义 s.push_back() 在末尾插入 例：s.push_back('a') 末尾插入一个字符a s.insert(pos,element) 在pos位置插入element 例：s.insert(s.begin(),'1') 在第一个位置插入1字符 s.append(str) 在s字符串结尾添加str字符串 例：s.append(&quot;abc&quot;) 在s字符串末尾添加字符串“abc” 删除 代码 含义 erase(iterator p) 删除字符串中p所指的字符 erase(iterator first, iterator last) 删除字符串中迭代器区间[first,last)上所有字符 erase(pos, len) 删除字符串中从索引位置pos开始的len个字符 clear() 删除字符串中所有字符 字符替换 代码 含义 s.replace(pos,n,str) 把当前字符串从索引pos开始的n个字符替换为str s.replace(pos,n,n1,c) 把当前字符串从索引pos开始的n个字符替换为n1个字符c s.replace(it1,it2,str) 把当前字符串[it1,it2)区间替换为str it1 ,it2为迭代器哦 大小写转换 法一： 代码 含义 tolower(s[i]) 转换为小写 toupper(s[i]) 转换为大写 法二： 通过stl的transform算法配合tolower 和toupper 实现。有4个参数，前2个指定要转换的容器的起止范围，第3个参数是结果存放容器的起始位置，第4个参数是一元运算。 123string s;transform(s.begin(),s.end(),s.begin(),::tolower);//转换小写transform(s.begin(),s.end(),s.begin(),::toupper);//转换大写 分割 代码 含义 s.substr(pos,n) 截取从pos索引开始的n个字符 查找 代码 含义 s.find (str, pos) 在当前字符串的pos索引位置（默认为0）开始，查找子串str，返回找到的位置索引，-1表示查找不到子串 s.find (c, pos) 在当前字符串的pos索引位置（默认为0）开始，查找字符c，返回找到的位置索引，-1表示查找不到字符 s.rfind (str, pos) 在当前字符串的pos索引位置开始，反向查找子串s，返回找到的位置索引，-1表示查找不到子串 s.rfind (c,pos) 在当前字符串的pos索引位置开始，反向查找字符c，返回找到的位置索引，-1表示查找不到字符 s.find_first_of (str, pos) 在当前字符串的pos索引位置（默认为0）开始，查找子串s的字符，返回找到的位置索引，-1表示查找不到字符 s.find_first_not_of (str,pos) 在当前字符串的pos索引位置（默认为0）开始，查找第一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到字符 s.find_last_of(str, pos) 在当前字符串的pos索引位置开始，查找最后一个位于子串s的字符，返回找到的位置索引，-1表示查找不到字符 s.find_last_not_of ( str, pos) 在当前字符串的pos索引位置开始，查找最后一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到子串 123456789101112131415161718192021222324252627282930#include&lt;string&gt;#include&lt;iostream&gt;int main() { string s(&quot;dog bird chicken bird cat&quot;);//字符串查找-----找到后返回首字母在字符串中的下标// 1. 查找一个字符串 cout &lt;&lt; s.find(&quot;chicken&quot;) &lt;&lt; endl;// 结果是：9 // 2. 从下标为6开始找字符'i'，返回找到的第一个i的下标 cout &lt;&lt; s.find('i',6) &lt;&lt; endl;// 结果是：11 // 3. 从字符串的末尾开始查找字符串，返回的还是首字母在字符串中的下标 cout &lt;&lt; s.rfind(&quot;chicken&quot;) &lt;&lt; endl;// 结果是：9 // 4. 从字符串的末尾开始查找字符 cout &lt;&lt; s.rfind('i') &lt;&lt; endl;// 结果是：18因为是从末尾开始查找，所以返回第一次找到的字符 // 5. 在该字符串中查找第一个属于字符串s的字符 cout &lt;&lt; s.find_first_of(&quot;13br98&quot;) &lt;&lt; endl;// 结果是：4---b // 6. 在该字符串中查找第一个不属于字符串s的字符------先匹配dog，然后bird匹配不到，所以打印4 cout &lt;&lt; s.find_first_not_of(&quot;hello dog 2006&quot;) &lt;&lt; endl; // 结果是：4 cout &lt;&lt; s.find_first_not_of(&quot;dog bird 2006&quot;) &lt;&lt; endl; // 结果是：9 // 7. 在该字符串最后中查找第一个属于字符串s的字符 cout &lt;&lt; s.find_last_of(&quot;13r98&quot;) &lt;&lt; endl;// 结果是：19// 8. 在该字符串最后中查找第一个不属于字符串s的字符------先匹配t--a---c，然后空格匹配不到，所以打印21 cout &lt;&lt; s.find_last_not_of(&quot;teac&quot;) &lt;&lt; endl;// 结果是：21} 排序 1sort(s.begin(),s.end());//按照ASCII排序 十、 bitset10.1 介绍bitset在bitset头文件中，它类似数组，并且每一个元素只能是0或1，每一个元素只用1bit空间 12//头文件#include&lt;bitset&gt; 10.2 初始化定义初始化方法 代码 含义 bitset a a有n位，每位都是0 bitset &lt; n &gt;a(b) a是unsigned long型u的一个副本 bitset &lt; n &gt;a(s) a是string对象s中含有的位串的副本 bitset &lt; n &gt;a(s,pos,n) a是s中从位置pos开始的n个位的副本 注意：n必须为常量表达式 演示代码： 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;int main() { bitset&lt;4&gt; bitset1; //无参构造，长度为４，默认每一位为０ bitset&lt;9&gt; bitset2(12); //长度为9，二进制保存，前面用０补充 string s = &quot;100101&quot;; bitset&lt;10&gt; bitset3(s); //长度为10，前面用０补充 char s2[] = &quot;10101&quot;; bitset&lt;13&gt; bitset4(s2); //长度为13，前面用０补充 cout &lt;&lt; bitset1 &lt;&lt; endl; //0000 cout &lt;&lt; bitset2 &lt;&lt; endl; //000001100 cout &lt;&lt; bitset3 &lt;&lt; endl; //0000100101 cout &lt;&lt; bitset4 &lt;&lt; endl; //0000000010101 return 0;} 10.3 特性bitset可以进行位操作 12345678910111213141516171819202122232425262728bitset&lt;4&gt; foo (string(&quot;1001&quot;));bitset&lt;4&gt; bar (string(&quot;0011&quot;));cout &lt;&lt; (foo^=bar) &lt;&lt; endl;// 1010 (foo对bar按位异或后赋值给foo)cout &lt;&lt; (foo&amp;=bar) &lt;&lt; endl;// 0001 (按位与后赋值给foo)cout &lt;&lt; (foo|=bar) &lt;&lt; endl;// 1011 (按位或后赋值给foo)cout &lt;&lt; (foo&lt;&lt;=2) &lt;&lt; endl;// 0100 (左移2位，低位补0，有自身赋值)cout &lt;&lt; (foo&gt;&gt;=1) &lt;&lt; endl;// 0100 (右移1位，高位补0，有自身赋值)cout &lt;&lt; (~bar) &lt;&lt; endl;// 1100 (按位取反)cout &lt;&lt; (bar&lt;&lt;1) &lt;&lt; endl;// 0110 (左移，不赋值)cout &lt;&lt; (bar&gt;&gt;1) &lt;&lt; endl;// 0001 (右移，不赋值)cout &lt;&lt; (foo==bar) &lt;&lt; endl;// false (1001==0011为false)cout &lt;&lt; (foo!=bar) &lt;&lt; endl;// true (1001!=0011为true)cout &lt;&lt; (foo&amp;bar) &lt;&lt; endl;// 0001 (按位与，不赋值)cout &lt;&lt; (foo|bar) &lt;&lt; endl;// 1011 (按位或，不赋值)cout &lt;&lt; (foo^bar) &lt;&lt; endl;// 1010 (按位异或，不赋值) 访问 123456//可以通过 [ ] 访问元素(类似数组)，注意最低位下标为０，如下：bitset&lt;4&gt; foo (&quot;1011&quot;); cout &lt;&lt; foo[0] &lt;&lt; endl; //1cout &lt;&lt; foo[1] &lt;&lt; endl; //0cout &lt;&lt; foo[2] &lt;&lt; endl; //1 10.4 方法函数 代码 含义 b.any() b中是否存在置为1的二进制位，有 返回true b.none() b中是否没有1，没有 返回true b.count() b中为1的个数 b.size() b中二进制位的个数 b.test(pos) 测试b在pos位置是否为1，是 返回true b[pos] 返回b在pos处的二进制位 b.set() 把b中所有位都置为1 b.set(pos) 把b中pos位置置为1 b.reset() 把b中所有位都置为0 b.reset(pos) 把b中pos位置置为0 b.flip() 把b中所有二进制位取反 b.flip(pos) 把b中pos位置取反 b.to_ulong() 用b中同样的二进制位返回一个unsigned long值","link":"/2024/07/10/C++/STL05/"},{"title":"STL学习打卡Day06","text":"十一、array数组11.1 介绍头文件： 1#include&lt;array&gt; array是C++11新增的容器，效率与普通数据相差无几，比vector效率要高，自身添加了一些成员函数。 和其它容器不同，array 容器的大小是固定的，无法动态的扩展或收缩，只允许访问或者替换存储的元素。 注意：array的使用要在std命名空间里 11.2 简实使用11.2.1 声明和初始化基础数据类型 声明一个大小位100的int型数组，元素的值不确定 1array&lt;int, 100&gt; a; 声明一个大小为100的int型数组，初始值均为0（初始值与默认元素类型等效）、 1array&lt;int, 100&gt; a{}; 声明一个大小为100的int型数组，初始化部分值，其余全部为0 1array&lt;int, 100&gt; a{1, 2, 3}; 或者可以用等号 1array&lt;int, 100&gt; a = {1, 2, 3}; 高级数据类型 不同于数组的是对元素类型不做要求，可以套结构体 12array&lt;string, 2&gt; s = {&quot;ha&quot;, string(&quot;haha&quot;)};array&lt;node, 2&gt; a; 11.2.2. 取存元素值修改元素 12array&lt;int, 4&gt; a = {1, 2, 3, 4};a[0] = 4; 访问元素 下标访问: 123array&lt;int, 4&gt; a = {1, 2, 3, 4};for(int i = 0; i &lt; 4; i++) cout &lt;&lt; a[i] &lt;&lt; &quot; \\n&quot;[i == 3]; 利用auto访问: 12for(auto i : a) cout &lt;&lt; i &lt;&lt; &quot; &quot;; 迭代器访问: 123auto it = a.begin();for(; it != a.end(); it++) cout &lt;&lt; *it &lt;&lt; &quot; &quot;; at()函数访问： 下标为1的元素加上下标为2的元素，答案为5 123array&lt;int, 4&gt; a = {1, 2, 3, 4};int res = a.at(1) + a.at(2);cout &lt;&lt; res &lt;&lt; &quot;\\n&quot;; get方法访问: 将a数组下标为1位置处的值改为x.获取的下标只能写数字，不能填变量 1get&lt;1&gt;(a) = x; 11.3 成员函数 成员函数 功能 begin() 返回容器中第一个元素的访问迭代器（地址） end() 返回容器最后一个元素之后一个位置的访问迭代器（地址） rbegin() 返回最后一个元素的访问迭代器（地址） rend() 返回第一个元素之前一个位置的访问迭代器（地址） size() 返回容器中元素的数量，其值等于初始化 array 类的第二个模板参数N max_size() 返回容器可容纳元素的最大数量，其值始终等于初始化 array 类的第二个模板参数 N empty() 判断容器是否为空 at(n) 返回容器中 n 位置处元素的引用，函数会自动检查 n 是否在有效的范围内，如果不是则抛出 out_of_range 异常 front() 返回容器中第一个元素的直接引用，函数不适用于空的 array 容器 back() 返回容器中最后一个元素的直接引用，函数不适用于空的 array 容器。 data() 返回一个指向容器首个元素的指针。利用该指针，可实现复制容器中所有元素等类似功能 fill(x) 将 x 这个值赋值给容器中的每个元素,相当于初始化 array1.swap(array2) 交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型 11.4 部分用法示例data()指向底层元素存储的指针。对于非空容器，返回的指针与首元素地址比较相等。 at()下标为1的元素加上下标为2的元素，答案为5 123array&lt;int, 4&gt; a = {1, 2, 3, 4};int res = a.at(1) + a.at(2);cout &lt;&lt; res &lt;&lt; &quot;\\n&quot;; fill()array的fill()函数，将a数组全部元素值变为x 1a.fill(x); 另外还有其它的fill()函数:将a数组[begin,end]全部值变为x 1fill(a.begin(), a.end(), x); get方法获取元素值将a数组下标为1位置处的值改为x ⭐️注意⭐️获取的下标只能写数字，不能填变量 1get&lt;1&gt;(a) = x; 排序1sort(a.begin(), a.end()); 十二、 tuple12.1 介绍tuple模板是pair的泛化，可以封装不同类型任意数量的对象。 可以把tuple理解为pair的扩展，tuple可以声明二元组，也可以声明三元组。 tuple可以等价为结构体使用 ❤️ 头文件 1#include&lt;tuple&gt; 12.2 基础用法12.2.1 声明及初始化 声明一个空的tuple三元组 1tuple&lt;int, int, string&gt; t1; 赋值 1t1 = make_tuple(1, 1, &quot;hahaha&quot;); 创建的同时初始化 1tuple&lt;int, int, int, int&gt; t2(1, 2, 3, 4); 可以使用pair对象构造tuple对象，但tuple对象必须是两个元素 12auto p = make_pair(&quot;wang&quot;, 1);tuple&lt;string, int&gt; t3 {p}; //将pair对象赋给tuple对象 12.2.2 元素操作获取tuple对象t的第一个元素 1int first = get&lt;0&gt;(t); 修改tuple对象t的第一个元素 1get&lt;0&gt;(t) = 1; 12.3 函数操作 获取元素个数 12tuple&lt;int, int, int&gt; t(1, 2, 3);cout &lt;&lt; tuple_size&lt;decltype(t)&gt;::value &lt;&lt; &quot;\\n&quot;; // 3 获取对应元素的值 通过get&lt;n&gt;(obj)方法获取,n必须为数字不能是变量 1234tuple&lt;int, int, int&gt; t(1, 2, 3);cout &lt;&lt; get&lt;0&gt;(t) &lt;&lt; '\\n'; // 1cout &lt;&lt; get&lt;1&gt;(t) &lt;&lt; '\\n'; // 2cout &lt;&lt; get&lt;2&gt;(t) &lt;&lt; '\\n'; // 3 通过tie解包 获取元素值 tie可以让tuple变量中的三个值依次赋到tie中的三个变量中 12345int one, three;string two; tuple&lt;int, string, int&gt; t(1, &quot;hahaha&quot;, 3);tie(one, two, three) = t;cout &lt;&lt; one &lt;&lt; two &lt;&lt; three &lt;&lt; &quot;\\n&quot;; // 1hahaha3","link":"/2024/07/10/C++/STL06/"},{"title":"STL学习打卡Day07","text":"STL学习 十三、STL函数beg为序列的初始地址 end为序列的尾地址 accumulate1accumulate(beg, end, init) 复杂度: O(N) 作用：对一个序列的元素求和 init为对序列元素求和的初始值 返回值类型：与init 相同 基础累加求和： 1234567int a[]={1, 3, 5, 9, 10};//对[0,2]区间求和，初始值为0，结果为0 + 1 + 3 + 5 = 9int res1 = accumulate(a, a + 3, 0);//对[0,3]区间求和，初始值为5，结果为5 + 1 + 3 + 5 + 9 = 23int res2 = accumulate(a, a + 4, 5); 自定义二元对象求和 使用lambda表达式 123456789101112typedef long long ll;struct node { ll num;} st[10];for(int i = 1; i &lt;= n; i++) st[i].num = i + 10000000000;//返回值类型与init一致，同时注意参数类型（a）也要一样//初始值为1，累加1+10000000001+10000000002+10000000003=30000000007ll res = accumulate(st + 1, st + 4, 1ll, [](ll a,node b) { return a + b.num;}); atoi1atoi(const char *) 将字符串转换为int类型 注意参数为char型数组，如果需要将string类型转换为int类型，可以使用stoi函数（参考下文），或者将string类型转换为const char *类型。 关于输出数字的范围：atoi不做范围检查，如果超出上界，输出上界，超出下界，输出下界。stoi会做范围检查，默认必须在int范围内，如果超出范围，会出现RE（Runtime Error）错误。 123string s = &quot;1234&quot;;int a = atoi(s.c_str());cout &lt;&lt; a &lt;&lt; &quot;\\n&quot;; // 1234 或者 123char s[] = &quot;1234&quot;;int a = atoi(s);cout &lt;&lt; a &lt;&lt; &quot;\\n&quot;; fill1fill(beg, end, num) 复杂度： O(N) 一个序列进行初始化赋值 123456//对a数组的所有元素赋1int a[5];fill(a, a + 5, 1);for(int i = 0; i &lt; 5; i++) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;//1 1 1 1 1 注意区分memset： memset()是按字节进行赋值，对于初始化赋0或-1有比较好的效果. 如果赋某个特定的数会出错，赋值特定的数建议使用fill() is_sorted1is_sorted(beg, end) 复杂度： O (N) 判断序列是否有序（升序），返回bool值 123//如果序列有序，输出YESif(is_sorted(a, a + n)) cout &lt;&lt; &quot;YES\\n&quot;; iota1iota(beg, end) 让序列递增赋值 12345vector&lt;int&gt; a(10);iota(a.begin(), a.end(), 0);for(auto i : a) cout &lt;&lt; i &lt;&lt; &quot; &quot;;// 0 1 2 3 4 5 6 7 8 9 lower_bound + upper_bound复杂度： O(logN) 作用：二分查找 123456//在a数组中查找第一个大于等于x的元素，返回该元素的地址lower_bound(a, a + n, x);//在a数组中查找第一个大于x的元素，返回该元素的地址upper_bound(a, a + n, x);//如果未找到，返回尾地址的下一个位置的地址 max_element+min_element复杂度： O(N) 找最大最小值 123//函数都是返回地址，需要加*取值int mx = *max_element(a, a + n);int mn = *min_element(a, a + n); max+min复杂度： O(1)找多个元素的最大值和最小值 123//找a，b的最大值和最小值mx = max(a, b);mn = min(a, b); 123//找到a,b,c,d的最大值和最小值mx = max({a, b, c, d});mn = min({a, b, c, d}); minmax复杂度： O(1) 返回一个pair类型，第一个元素是min(a, b)， 第二个元素是max(a, b) 12pair&lt;int, int&gt; t = minmax(4, 2);// t.first = 2, t.second = 4 minmax_element1minmax_element(beg, end) 复杂度： O(N) 返回序列中的最小和最大值组成pair的对应的地址，返回类型为pair&lt;vector&lt;int&gt;::iterator, vector&lt;int&gt;::iterator&gt; 12345int n = 10;vector&lt;int&gt; a(n);iota(a.begin(), a.end(), 1);auto t = minmax_element(a.begin(), a.end()); // 返回的是最小值和最大值对应的地址// *t.first = 1, *t.second = 10 输出对应最小最大值时需要使用指针 nth_element1nth_element(beg, nth, end) 复杂度： 平均O(N) 寻找第序列第n小的值 nth为一个迭代器，指向序列中的一个元素。第n小的值恰好在nth位置上。 执行nth_element()之后，序列中的元素会围绕nth进行划分：nth之前的元素都小于等于它，而之后的元素都大于等于它 实例：求序列中的第3小的元素 12nth_element(a, a + 2, a + n);cout &lt;&lt; a[2] &lt;&lt; '\\n'; next_permutation1next_permutation(beg, end) 复杂度： O(N) 求序列的下一个排列，下一个排列是字典序大一号的排列 返回true或false next_permutation(beg, end) 如果是最后一个排列，返回false,否则求出下一个序列后，返回true 12//对a序列进行重排next_permutation(a, a + n); 应用：求所有的排列 输出a的所有排列 123456// 数组a不一定是最小字典序序列，一定注意将它排序sort(a, a + n);do { for(int i = 0; i &lt; n; i++) printf(&quot;%d &quot;, a[i]);} while(next_permutation(a, a + n)); prev_permutation(beg, end) 求出前一个排列，如果序列为最小的排列，将其重排为最大的排列，返回false partial_sort1partial_sort(beg, mid, end) 复杂度： 大概O(NlogM) M为距离 部分排序,排序mid-beg个元素，mid为要排序区间元素的尾后的一个位置 从beg到mid前的元素都排好序 对a数组前5个元素排序按从小到大排序 123456int a[] = {1,2,5,4,7,9,8,10,6,3};partial_sort(a, a + 5, a + 10);for(int i = 0; i &lt; 10; i++) cout &lt;&lt; a[i] &lt;&lt; ' ';//1 2 3 4 5 9 8 10 7 6//前五个元素都有序 也可以添加自定义排序规则: 1partial_sort(beg,mid,end,cmp) 对a的前五个元素都是降序排列 123456int a[] = {1,2,5,4,7,9,8,10,6,3};partial_sort(a, a + 5, a + 10, greater&lt;int&gt;());for(int i = 0; i &lt; 10; i++) cout &lt;&lt; a[i] &lt;&lt; ' ';//10 9 8 7 6 1 2 4 5 3//前五个元素降序有序 random_shuffle复杂度： O(N) 随机打乱序列的顺序 random_shuffle 在 C++14 中被弃用，在 C++17 中被废除，C++11之后应尽量使用shuffle来代替。 123456vector&lt;int&gt; b(n);iota(b.begin(), b.end(), 1);// 序列b递增赋值 1, 2, 3, 4,...// 对a数组随机重排random_shuffle(a, a + n);// C++11之后尽量使用shuffleshuffle(b.begin(), b.end()); **reverse **1reverse(beg,end) 复杂度： O(N) 对序列进行翻转 12345678string s = &quot;abcde&quot;;reverse(s.begin(), s.end());//对s进行翻转cout &lt;&lt; s &lt;&lt; '\\n';//edcba//对a数组进行翻转int a[] = {1, 2, 3, 4};reverse(a, a + 4);cout &lt;&lt; a[0] &lt;&lt; a[1] &lt;&lt; a[2] &lt;&lt; a[3];//4321 set_union, set_intersection,set_difference复杂度： O(N+M) 求两个集合的并集，交集，差集。手动实现双指针就可以搞定，嫌麻烦可以使用该函数。 注意：两个集合必须为有序集合，所以下面演示代码使用了排序。vector容器可以替换成set容器，因为set自动会对元素进行排序。 函数的参数有五个，前两个为第一个容器的首尾迭代器，第三四个为第二个容器的首尾迭代器，最后一个为插入位置，即将结果插入到哪个地址之后。 12345678910vector&lt;int&gt; a = {4, 5, 2, 1, 8}, b = {5, 3, 8, 9, 2};sort(a.begin(), a.end()); // 1 2 4 5 8sort(b.begin(), b.end()); // 2 3 5 8 9vector&lt;int&gt; c, d, e;// a并b：1 2 3 4 5 8 9set_union(a.begin(), a.end(), b.begin(), b.end(), inserter(c, c.begin()));// a交b：2 5 8set_intersection(a.begin(), a.end(), b.begin(), b.end(), inserter(d, d.begin()));// a差b： 1 4set_difference(a.begin(), a.end(), b.begin(), b.end(), inserter(e, e.begin())); sort复杂度： O(NlogN) 作用：对一个序列进行排序 123//原型：sort(beg, end);sort(beg, end, cmp); 几种排序的常见操作： 操作一：对数组正常升序排序 123456int a[N]; // 普通数组定义// 对 a 数组的[1, n]位置进行从小到大排序sort(a + 1, a + 1 + n);vector&lt;int&gt; b(n + 1); // vector数组定义sort(b.begin() + 1, b.end()); 操作二：使用第三个参数，进行降序排序 12345678//对a数组的[0, n-1]位置从大到小排序sort(a, a + n, greater&lt;int&gt;());//对a数组的[0, n-1]位置从小到大排序sort(a, a + n, less&lt;int&gt;());vector&lt;int&gt; b(n + 1);sort(b.begin() + 1, b.end()); // 升序sort(b.begin() + 1, b.end(), greater&lt;int&gt;()); // 降序 操作三：另外一种降序排序方法，针对 vector 12vector&lt;int&gt; a(n);sort(a.rbegin(), a.rend()); // 使用反向迭代器进行降序排序 操作四：自定义排序规则 1234567891011// 1. 使用函数自定义排序，定义比较函数bool cmp(node a, node b) { //按结构体里面的x值降序排列 return a.x &gt; b.x;}sort(node, node + n, cmp); // 只能接受 以函数为形式的自定义排序规则，无法接受以结构体为形式的自定义排序规则// 2. 或者使用匿名函数自定义排序规则sort(node, node + n, [](node a, node b) { return a.x &gt; b.x;}); stable_sort复杂度： O(NlogN) 功能和 sort() 基本一样 区别在于stable_sort()能够保证相等元素的相对位置，排序时不会改变相等元素的相对位置 使用用法和sort()一样，见上 stoi1stoi(const string*) 将对应string类型字符串转换为数字，记忆：s -&gt; t 分别对应两个数据类型的某个字母 注意参数为string字符串类型。 关于输出数字的范围： stoi会做范围检查，默认必须在int范围内，如果超出范围，会出现RE（Runtime Error）错误。 atoi不做范围检查，如果超出上界，输出上界，超出下界，输出下界 123string s = &quot;1234&quot;;int a = stoi(s);cout &lt;&lt; a &lt;&lt; &quot;\\n&quot;; // 1234 transform复杂度： O(N) 作用：使用给定操作，将结果写到dest中 12//原型：transform(beg, end, dest, unaryOp); 一般不怎么使用，徒增记忆负担，不如手动实现。 123//将序列开始地址beg到结束地址end大小写转换，把结果存到起始地址为dest的序列中transform(beg, end, dest, ::tolower);transform(beg, end, dest, ::toupper) to_string将数字转化为字符串，支持小数（double） 12int a = 12345678;cout &lt;&lt; to_string(a) &lt;&lt; '\\n'; unique1unique(beg, end) 复杂度： O(N) 消除重复元素，返回消除完重复元素的下一个位置的地址 如：a[] = {1, 3, 2, 3, 6}; unique 之后 a 数组为{1, 2, 3, 6, 3}前面为无重复元素的数组，后面则是重复元素移到后面，返回a[4]位置的地址（不重复元素的尾后地址） 消除重复元素一般需要原序列是有序序列 应用：离散化: 方法一：利用数组离散化 12345678910111213for(int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i]; b[i] = a[i];//将a数组复制到b数组}// 排序后 b：{1, 2, 3, 3, 6}sort(b, b + n);//对b数组排序// 消除重复元素b：{1, 2, 3, 6, 3} 返回的地址为最后一个元素3的地址 int len = unique(b, b + n) - b;//消除 b 的重复元素，并获取长度for(int i = 0; i &lt; n; i++) { //因为b有序，查找到的下标就是对应的 相对大小（离散化后的值） int pos = lower_bound(b, b + len, a[i]) - b;//在b数组中二分查找第一个大于等于a[i]的下标 a[i] = pos; // 离散化赋值} 方法二：利用 vector 进行离散化 12345678910vector&lt;int&gt; a(n);for (int i = 0; i &lt; n; ++i) { cin &gt;&gt; a[i];}vector&lt;int&gt; b = a;sort(b.begin(), b.end());b.erase(unique(b.begin(), b.end()), b.end());for (int i = 0; i &lt; n; ++i) { a[i] = lower_bound(b.begin(), b.end(), a[i]) - b.begin() + 1; // 离散后的数据从1开始 } __gcd1__gcd(a, b) 求a和b的最大公约数 12__gcd(12,15) = 3__gcd(21,0) = 21 __lg1__lg(a) 求一个数二进制下最高位位于第几位（从第0位开始）（或二进制数下有几位） __lg(x)相当于返回⌊ log_2 x ⌋ 复杂度O(1) 12__lg(8) = 3__lg(15) = 3 _builtin 内置位运算函数需要注意：内置函数有相应的unsigned lnt和unsigned long long版本，unsigned long long只需要在函数名后面加上ll就可以了，比如__builtin_clzll(x) ，默认是32位unsigned int 很多题目和 long long 数据类型有关，如有需要注意添加 ll __builtin_ffs1__builtin_ffs(x) 二进制中对应最后一位1的位数，比如4会返回3（100） __builtin_popcount1__builtin_popcount(x) x中1的个数 __builtin_ctz1__builtin_ctz(x) x末尾0的个数（count tail zero） __builtin_clz1__builtin_clz(x) x前导0的个数（count leading zero） 12cout &lt;&lt; __builtin_clz(32); // 26//因为共有6位,默认数据范围为32位，32 - 6 = 26 __builtin_parity1__builtin_parity(x) 1x`中1的个数的奇偶性， 奇数输出`1`，偶数输出`0 可参考链接： C++语法糖 https://www.luogu.com.cn/blog/AccRobin/grammar-candies","link":"/2024/07/10/C++/STL07/"},{"title":"手撕transformer","text":"Transformer是当代自然语言处理领域不可或缺的模型。本文作者最近学习大语言模型，而Transformer就是大语言模型的基础，所以书写本文通过PyTorch实现Transformer. Pytorch实现TransformerTransformer是当代自然语言处理领域不可或缺的模型。本文作者最近学习大语言模型，而Transformer就是大语言模型的基础，所以书写本文通过PyTorch实现Transformer. Preparing首先，先导入所需要的包： 12345import torch from torch import nnfrom torch import optimfrom torch.utils import data as Dataimport numpy as np 后面需要使用一些有关Transformer的超参数，所以在开头先定义出来： 1234567d_model = 512max_len = 1024d_ff = 2048d_k = d_v = 64n_layers = 6n_heads = 8p_drop = 0.1 变量名依次是： d_model: Embedding的大小 max_len: 输入序列的最长大小 d_ff: 前馈神经网络的隐藏层大小，一般是 d_model的四倍 d_k, d_v : 自注意力中K和V的维度， Q的维度直接用K的维度代替，因为这两者必须始终相等 n_layers: Encoder和Decoder的层数 n_heads: 自注意力多头的头数 p_drop: Dropout的概率 MaskMask分为两种，一种是因为在数据中使用了padding，不希望pad被加入到注意力中进行计算的Pad Mask for Attention，还有一种是保证Decoder自回归信息不泄露的Subsequent Mask for Decoder。 Pad Mask for Attention为了方便，假设 在字典中的index是0，遇到输入为0直接将其标为True。 123456789101112131415161718def get_attn_pad_mask(seq_q, seq_k): ''' Padding, because of unequal in source_len and target_len. parameters: seq_q: [batch, seq_len] seq_k: [batch, seq_len] return: mask: [batch, len_q, len_k] ''' batch, len_q = seq_q.size() batch, len_k = seq_k.size() pad_attn_mask = seq_k.data.eq(0).unsqueeze(1) return pad_attn_mask.expand(batch, len_q, len_k) 在Encoder和Decoder中使用Mask的情况可能各有不同: 在Encoder中使用Mask, 是为了将encoder_input中没有内容而打上PAD的部分进行Mask, 方便矩阵运算. 在Decoder中使用Mask, 可能是在Decoder的自注意力对decoder_input 的PAD进行Mask, 也有可能是对Encoder - Decoder自注意力时对encoder_input和decoder_input的PAD进行Mask Subsequent Mask for Decoder该Mask是为了防止Decoder的自回归信息泄露而生的Mask, 直接生成一个上三角矩阵即可: 123456789101112131415def get_attn_subsequent_mask(seq): ''' Build attention mask matrix for decoder when it autoregressing. parameters: seq: [batch, target_len] return: subsequent_mask: [batch, target_len, target_len] ''' attn_shape = [seq.size(0), seq.size(1), seq.size(1)] # [batch, target_len, target_len] subsequent_mask = np.triu(np.ones(attn_shape), k=1) # [batch, target_len, target_len] subsequent_mask = torch.from_numpy(subsequent_mask) return subsequent_mask # [batch, target_len, target_len] Positional Encoding在Transformer中, 使用的是绝对位置编码, 用于传输给模型Self - Attention所不能传输的位置信息, 编码使用正余弦公式实现: 1234567891011121314151617181920class PositionalEncoding(nn.Module): def __init__(self, d_model, drop_out=0.1, max_len=1024): super(PositionalEncoding, self).__init__() self.dropout = nn.Dropout(p = p_drop) positional_encoding = torch.zeros(max_len, d_model) position = torch.arange(0, max_len).float().unsqueeze(1) div_term = torch.exp(torch.arange(0, d_model, 2).float() * (-torch.log(torch.Tensor([10000])) / d_model)) positional_encoding[:, 0::2] = torch.sin(position * div_term) positional_encoding[:, 1::2] = torch.cos(position * div_term) positional_encoding = positional_encoding.unsqueeze(0).transpose(0, 1) self.register_buffer('pe', postional_encoding) def forward(self, x): x = x + self.pe[:x.size(0), ...] return self.dropout(x) Feed Forward Neural Network在Transformer中, Encoder或者Decoder每个Block都需要用一个前馈神经网络来添加非线性: 注意, 这里它们都是有偏置的, 而且这两个Linear可以用两个1×1 的卷积来实现: 123456789101112131415161718192021class FeedForwardNetwork(nn.Module): ''' using nn.Conv1d replace nn.Linear to implements FFN ''' def __init__(self): super(FeedForwardNetwork, self).__init__() # self.ff1 = nn.Linear(d_model, d_ff) # self.ff2 = nn.Linear(d_ff, d_model) self.ff1 = nn.Conv1d(d_model, d_ff, 1) self.ff2 = nn.Conv1d(d_ff, d_model, 1) self.relu = nn.Relu() def forward(self, x): # x: [batch, seq_len, d_model] residual = x x = x.transpose(1, 2) x = self.ff1(x) x = self.relu(x) x = self.ff2(x) x = x.transpose(1, 2) return self.layer_norm(residual + x) 作为一个子层, 不要忘记Transformer中提到的Residual Connection和Layer Norm. 我选择用两个卷积代替Linear. 在nn.Conv1d中, 要求数据的规格为[batch, x, ...], 我们是要对d_model 上的数据进行卷积, 所以还是需要transpose一下 Multi - Head Attention先说多头注意力, 因为多头注意力能够决定缩放点积注意力的输入大小. 作为一个子层, 其中的Residual Connection和Layer Norm是必须的. 多头注意力是多个不同的头来获取不同的特征, 类似于多个卷积核所达到的效果. 在计算完后通过一个Linear调整大小: 多头注意力在Encoder和Decoder中的使用略有区别, 主要区别在于Mask的不同. 我们前面已经实现了两种Mask函数, 在这里会用到. 多头注意力实际上不是通过弄出很多大小相同的矩阵然后相乘来实现的, 只需要合并到一个矩阵进行计算: 12345678910111213141516171819202122232425262728class MultiHeadAttention(nn.Module): def __init__(self, n_heads = 8): super(MultiHeadAttention, self).__init__() self.n_heads = n_heads self.W_Q == nn.Linear(d_model, d_k * n_heads, bias = False) self.W_K == nn.Linear(d_model, d_k * n_heads, bias = False) self.W_V == nn.Linear(d_model, d_v * n_heads, bias = False) self.fc = nn.Linear(d_v * n_heads, d_model, bias) self.layer_norm = nn.LayerNorm(d_model) def forward(self, input_Q, input_K, input_V, attn_mask): residual, batch = input_Q, input_Q.size(0) Q = self.W_Q(input_Q).view(batch, -1, n_heads, d_k).transpose(1, 2) K = self.W_K(input_K).view(batch, -1, n_heads, d_k).transpose(1, 2) V = self.W_V(input_V).view(batch, -1, n_heads, d_v).transpose(1, 2) attn_mask = attn_mask.unsqueeze(1).repeat(1, n_heads, 1, 1) prob, attn = ScaledDotProductAttention()(Q, K, V, attn_mask) prob = prob.transpose(1, 2).contiguous() prob = prob.view(batch, -1, n_heads * d_v).contiguous() output = self.fc(prob) # [batch, len_q, d_model] return self.layer_norm(residual + output), attn 提两个非常重要的点: 在拆维度时不要破坏维度原来本身的意义. 虽然新版本已经有reshape函数可以用了, 但是仍然不要忘记, transpose后如果接permute或者view必须要加contiguous, 这是数据真实存储连续与否的问题, 请参见Pytorch之张量基础操作中的维度变换部分 Scaled DotProduct AttentionTranformer中非常重要的概念, 缩放点积注意力, 公式如下:实现起来非常简单, 只需要把Q, K两个矩阵一乘, 然后再缩放, 过一次Softmax, 再和V乘下: 1234567891011121314151617class ScaledDotProductAttention(nn.Module): def __init__(self): super(ScaledDotProductAttention, self).__init__() def forward(self, Q, K, V, attn_mask): ''' Q: [batch, n_heads, len_q, d_k] K: [batch, n_heads, len_k, d_k] V: [batch, n_heads, len_v, d_v] attn_mask: [batch, n_heads, seq_len, seq_len] ''' scores = torch.matmul(Q, K.transpose(-1, -2)) / np.sqrt(d_k) # [batch, n_heads, len_q, len_k] scores.masked_fill_(attn_mask, -1e9) attn = nn.Softmax(dim=-1)(scores) # [batch, n_heads, len_q, len_k] prob = torch.matmul(attn, V) # [batch, n_heads, len_q, d_v] return prob, attn masked_fill_能把传进来的Mask为True的地方全都填充上某个值, 这里需要用一个很大的负数来保证ex→0, 使得其在Softmax 中可以被忽略 Encoder先写出Encoder的每个Layer, 由多头注意力和FFN组成: 12345678910class EncoderLayer(nn.Module): def __init__(self): super(EncoderLayer, self).__init__() self.encoder_self_attn = MultiHeadAttention() self.ffn = FeedForwardNetwork() def forward(self, encoder_input, encoder_pad_mask): encoder_output, attn = self.encoder_self_attn(encoder_input, encoder_input, encoder_input, encoder_pad_mask ) encoder_output = self.ffn(encoder_output) return encoder_output, attn 对于给定的encoder_input和encoder_pad_pask, Encoder应该能够完成整个Block(Layer)的计算流程. 然后实现整个Encoder: 123456789101112131415161718192021class Encoder(nn.Module): def __init__(self): super(Encoder, self).__init__() self.source_embedding = nn.Embedding(source_vocab_size, d_model) self.positional_embedding = PositionalEncoding(d_model) self.layers = nn.ModuleList([EncoderLayer() for layer in range(n_layers)]) def forward(self, encoder_input): # encoder_input: [batch, source_len] encoder_output = self.source_embedding(encoder_input) # [batch, source_len, d_model] encoder_output = self.positional_embedding(encoder_output.transpose(0, 1)).transpose(0, 1) # [batch, source_len, d_model] encoder_self_attn_mask = get_attn_pad_mask(encoder_input, encoder_input) # [batch, source_len, source_len] encoder_self_attns = list() for layer in self.layers: # encoder_output: [batch, source_len, d_model] # encoder_self_attn: [batch, n_heads, source_len, source_len] encoder_output, encoder_self_attn = layer(encoder_output, encoder_self_attn_mask) encoder_self_attns.append(encoder_self_attn) return encoder_output, encoder_self_attns 对于整个Encoder, 直接将Token的Index传入Embedding中, 再添入位置编码, 之后就经过多层Transformer Encoder. 在传入Block前, 先需要计算Padding的Mask, 再将上层的输出作为下层输入依次迭代. Decoder其实实现了Encoder, Decoder的实现部分都是对应的. 先实现Decoder的Block: 12345678910111213141516171819202122232425262728class DecoderLayer(nn.Module): def __init__(self): super(DecoderLayer, self).__init__() self.decoder_self_attn = MultiHeadAttention() self.encoder_decoder_attn = MultiHeadAttention() self.ffn = FeedForwardNetwork() def forward(self, decoder_input, encoder_output, decoder_self_mask, decoder_encoder_mask): ''' decoder_input: [batch, target_len, d_mdoel] encoder_output: [batch, source_len, d_model] decoder_self_mask: [batch, target_len, target_len] decoder_encoder_mask: [batch, target_len, source_len] ''' # masked mutlihead attention # Q, K, V all from decoder it self # decoder_output: [batch, target_len, d_model] # decoder_self_attn: [batch, n_heads, target_len, target_len] decoder_output, decoder_self_attn = self.decoder_self_attn(decoder_input, decoder_input, decoder_input, decoder_self_mask) # Q from decoder, K, V from encoder # decoder_output: [batch, target_len, d_model] # decoder_encoder_attn: [batch, n_heads, target_len, source_len] decoder_output, decoder_encoder_attn = self.encoder_decoder_attn(decoder_output, encoder_output, encoder_output, decoder_encoder_mask) decoder_output = self.ffn(decoder_output) # [batch, target_len, d_model] return decoder_output, decoder_self_attn, decoder_encoder_attn 与Encoder相对应, 只不过因为多了一个Encoder - Decoder自注意力, 所以需要额外计算一个Encoder - Decoder的Mask. 然后写出整个Decoder: 123456789101112131415161718192021222324252627282930313233class Decoder(nn.Module): def __init__(self): super(Decoder, self).__init__() self.target_embedding = nn.Embedding(target_vocab_size, d_model) self.positional_embedding = PositionalEncoding(d_model) self.layers = nn.ModuleList([DecoderLayer() for layer in range(n_layers)]) def forward(self, decoder_input, encoder_input, encoder_output): ''' decoder_input: [batch, target_len] encoder_input: [batch, source_len] encoder_output: [batch, source_len, d_model] ''' decoder_output = self.target_embedding(decoder_input) # [batch, target_len, d_model] decoder_output = self.positional_embedding(decoder_output.transpose(0, 1)).transpose(0, 1) # [batch, target_len, d_model] decoder_self_attn_mask = get_attn_pad_mask(decoder_input, decoder_input) # [batch, target_len, target_len] decoder_subsequent_mask = get_attn_subsequent_mask(decoder_input) # [batch, target_len, target_len] decoder_encoder_attn_mask = get_attn_pad_mask(decoder_input, encoder_input) # [batch, target_len, source_len] decoder_self_mask = torch.gt(decoder_self_attn_mask + decoder_subsequent_mask, 0) decoder_self_attns, decoder_encoder_attns = [], [] for layer in self.layers: # decoder_output: [batch, target_len, d_model] # decoder_self_attn: [batch, n_heads, target_len, target_len] # decoder_encoder_attn: [batch, n_heads, target_len, source_len] decoder_output, decoder_self_attn, decoder_encoder_attn = layer(decoder_output, encoder_output, decoder_self_mask, decoder_encoder_attn_mask) decoder_self_attns.append(decoder_self_attn) decoder_encoder_attns.append(decoder_encoder_attn) return decoder_output, decoder_self_attns, decoder_encoder_attns 和Encoder相对应, 但Decoder和Encoder使用了两个不同的Embedding. 对于Mask, 可以把自回归Mask和Padding Mask用torch.gt整合成一个Mask, 送入其中. Transformer里面有一个Encoder, 一个Decoder, 在Decoder端还需要加上投影层来分类: 12345678910111213141516171819202122class Transformer(nn.Module): def __init__(self): super(Transformer, self).__init__() self.encoder = Encoder() self.decoder = Decoder() sefl.projection = nn.Linear(d_model, target_vovab_size, bias = False) def forward(self, encoder_input, decoder_input): ''' encoder_input: [batch, source_len] decoder_input: [batch, target_len] ''' # encoder_output: [batch, source_len, d_model] # encoder_attns: [n_layers, batch, n_heads, source_len, source_len] encoder_output, encoder_attns = self.encoder(encoder_input) # decoder_output: [batch, target_len, d_model] # decoder_self_attns: [n_layers, batch, n_heads, target_len, target_len] # decoder_encoder_attns: [n_layers, batch, n_heads, target_len, source_len] decoder_output, decoder_self_attns, decoder_encoder_attns = self.decoder(decoder_input, encoder_input, encoder_output) decoder_logits = self.projection(decoder_output) # [batch, target_len, target_vocab_size] # decoder_logits: [batch * target_len, target_vocab_size] return decoder_logits.view(-1, decoder_logits.size(-1)), encoder_attns, decoder_self_attns, decoder_encoder_attns 最后对logits的处理是view成了[batch * target_len, target_vocab_size], 前面的大小并不影响我们一会用交叉熵计算损失.","link":"/2024/09/19/NLP/%E6%89%8B%E6%92%95transformer/"},{"title":"Buffer of Thoughts：Thought-Augmented Reasoning with Large Language Models","text":"这里是前言 施工中 版权声明：本文为原创，转载请注明出处。","link":"/2025/05/31/Research/Buffer%20of%20Thoughts%EF%BC%9AThought-Augmented%20Reasoning%20with%20Large%20Language%20Models/"},{"title":"ReasonFlux阅读","text":"单位： Princeton University， Peking UniversityCode: https://github.com/Gen-Verse/ReasonFlux基座模型： Qwen2.5-32B-Instruct原文地址：https://arxiv.org/pdf/2502.06772显卡：8 * NVIDIA A100 GPU 单位： Princeton University， Peking UniversityCode: https://github.com/Gen-Verse/ReasonFlux基座模型： Qwen2.5-32B-Instruct原文地址：https://arxiv.org/pdf/2502.06772显卡：8 * NVIDIA A100 GPU 备注：和之前的SUPERCORRECT、是同一位作者，这也是SUPERCORRECT的一个继承工作。 摘要： ReasonFlux提出，通过扩展思维模板的分层LLM推理能够有效优化推理搜索空间，并在数学推理能力上超越强大的LLM模型。使用8 * NVIDIA A100 GPU训练了ReasonFlux-32B模型，显著提升了数学推理能力，达到了最先进的水平。 Introduction大型语言模型（LLMs）最近取得了显著进展，展示了在解决复杂推理任务方面的卓越能力，甚至在某些特定领域超越了人类专家。例如，OpenAI的O1（Jaech等，2024）、Google的Gemini-2.0（Team等，2024）、DeepSeek-V3（Liu等，2024b）和Qwen-QwQ（Team，2024a）等模型处于这一进展的前沿，它们通过更慢、更慎重的思维过程来模拟人类推理。这些模型利用增加的推理时间来提高推理准确性。尽管它们已经解锁了显著的性能提升，但更复杂的任务，如AIME中的数学问题解决、OlympiadBench（He等，2024）和LiveCodeBench（Jain等，2024）中的代码，这些任务需要在庞大的解空间中进行更细粒度的搜索，并对每个复杂的推理步骤进行更精细的思考，因此仍然构成了重大挑战。 后续研究集中于通过推理时策略来增强大型语言模型在复杂问题上的推理能力。这些策略可以分为两类：刻意搜索和奖励模型引导的方法。刻意搜索方法，如思维树（Tree of Thoughts, ToT）（Yao et al., 2024）和思维图（Graph of Thoughts, GoT）（Besta et al., 2024），允许大语言模型（LLMs）探索多种推理路径并自我评估选择，以找到最优的推理轨迹。奖励模型引导的方法则利用奖励模型来评估推理步骤的质量。最佳N选一（Best-of-N）方法利用结果奖励模型（Outcome Reward Model, ORM）在多个候选路径中找到最优的推理路径，而过程奖励模型（Process Reward Models, PRMs）（Lightman et al., 2023; Luo et al., 2024; Wang et al., 2024）则通过奖励高概率的中间步骤，引导模型走向有潜力的路径。在此基础上，蒙特卡洛树搜索（Monte Carlo Tree Search, MCTS）（Zhang et al., 2024a; Qi et al., 2024）采用细粒度的搜索，将任务分解为更简单的步骤，并使用PRMs在基于树的搜索空间中指导动作选择。然而，这些方法通常会产生较高的计算成本，尤其是在推理步骤较多或搜索空间较大的情况下，这主要是由于采样的随机性，阻碍了高效识别最优推理轨迹。此外，它们依赖于手动设计的搜索策略和实例/步骤级别的奖励，限制了其在多样化和复杂推理任务中的泛化能力。本质上，这些方法在推理扩展时难以有效平衡探索与利用的权衡。这凸显了对一种更高效且可泛化的推理扩展方法的需求，该方法能够在无需大量手动干预的情况下增强推理能力，并提供更原则性的搜索策略。 为了实现更高效和精确的推理路径搜索，一种可行的方法是使用检索增强生成（Retrieval-Augmented Generation, RAG）。最近的思维缓冲（Buffer of Thought, BoT）（Yang et al., 2024b）构建了一个元缓冲，用于存储从各种问题解决过程中提炼出的信息丰富、高层次的思维，并自适应地检索和实例化与每个特定任务相关的思维模板。SuperCorrect（Yang et al., 2024c）进一步利用高层次和详细的思维模板来增强小型语言模型（LLMs）的推理能力。尽管取得了显著改进，这种基于模板的推理方法在应用于复杂推理任务时仍可能面临挑战。因为复杂问题通常需要整合多个模板或多样化的检索信息，而当前的方法在这方面仍难以有效应对。 为此，我们引入了ReasonFlux，这是一种新颖的分层LLM推理框架，通过在推理时自动检索相关的高级思维模板来配置最优的思维模板轨迹，从而在复杂推理任务上实现卓越性能，甚至超越了OpenAI的o1-preview和o1-mini模型。具体来说，我们首先构建了一个结构化的模板库，其中包含500个有用的压缩思维模板，以便于高效检索和适配。我们不再优化一个长的CoT（Chain-of-Thought）轨迹，而是对一系列高级思维模板进行分层强化学习，优化基础LLM以从多个模板中学习最优的思维模板轨迹，并引导推理LLM解决一系列更简单的子问题。最后，我们通过自适应缩放思维模板开发了一种新的推理缩放系统。这种分层推理范式使ReasonFlux能够简化推理路径的搜索，并通过为每个子问题动态选择最合适的高级模板来增强复杂问题的推理能力。我们的自动模板缩放使ReasonFlux能够有效地实现更好的探索与利用的权衡，从而带来更稳健和高效的问题解决过程。通过这些创新，ReasonFlux为增强LLM的复杂推理能力提供了一个更高效、可泛化和可扩展的解决方案。最后，我们将我们的贡献总结如下： 我们引入了ReasonFlux（如图1所示），这是一个分层次的LLM推理框架，显著增强了复杂推理能力，在具有挑战性的MATH和AIME基准测试中（如表2所示）超越了SOTA模型，如o1-preview和DeepSeek-V3。 我们提出了一个结构化和紧凑的模板库，其中包含从具有挑战性的数学问题中精选的约500个思维模板。该库有助于高效检索和适配相关的高级思维模板，用于一系列详细的推理步骤。 我们开发了基于一系列高级思维模板的分层次强化学习，使LLM能够为一系列较简单的子问题生成最优的思维模板轨迹，从而有效简化推理路径的搜索空间。 我们设计了一个新的推理扩展系统（如图2所示），通过自适应扩展思维模板进行分层次推理。该系统使ReasonFlux能够在推理时动态检索一系列高级模板，并自适应地执行实例化推理，从而在探索与利用之间实现更好的平衡，以进行稳健且高效的问题解决。 Related Work and Discussions从语言模型的偏好中学习 偏好学习对于将大型语言模型（LLMs）与人类的期望和感知对齐至关重要。最初的方法基于预训练和监督微调（SFT），并在从人类/人工智能反馈的强化学习（RLHF/RLAIF）框架中采用了PPO（Schulman等，2017；Christiano等，2017；Ouyang等，2022；Xie等，2024）。这些方法通常涉及在偏好对上训练奖励模型，随后优化LLM以最大化学习到的奖励。然而，PPO的不稳定性和低效性促使了替代方法的出现，如DPO（Rafailov等，2024），它直接从成对偏好数据中优化策略。后续研究解决了各种挑战。ORPO（Hong等，2024）将对齐整合到SFT中，KTO（Ethayarajh等，2024）利用点数据，简化了数据获取过程。其他努力集中在更细粒度的优化上，如Step-DPO（Lai等，2024）和Cross-DPO（Yang等，2024c），它们针对中间推理或反思步骤。SPO（Swamy等，2024）采用博弈论概念来解决非传递性偏好，而Multi-turn DPO（Shi等，2024）将优化扩展到对话中。然而，现有方法通常依赖于实例或步骤级别的奖励单位，可能无法捕捉和奖励人类问题解决过程中固有的高级认知过程。为此，我们引入了基于层次化RL的优化，这是一种新颖的偏好学习方法，鼓励模型配置一系列高级思维模板，以处理复杂问题的多样化子任务，从而在LLMs中促进更类似人类的问题解决策略。 检索增强生成语言模型 检索增强生成语言模型（Retrieval-Augmented Language Models, RALMs）已成为一种有效的方法，用于减少幻觉并提升大语言模型（LLMs）的事实准确性（Asai等，2023；Mialon等，2023；Shi等，2023；Gao等，2023；Zhao等，2024）。通过从大规模外部知识源（Borgeaud等，2022）中检索相关文档以指导响应生成，RALMs在问答任务中展现出卓越的性能，且通常比传统LLMs所需的参数更少（Mialon等，2023）。其多功能性在多样化任务中的成功应用进一步得到验证，包括多模态生成和生物医学应用（Yasunaga等，2023；Izacard等，2023；Wang等，2022；Zhao等，2024；Borgeaud等，2022；Yang等，2023）。然而，RALMs在复杂推理任务（如数学和代码）中面临挑战，其中通过标准嵌入相似性搜索检索相关指南或模板较为困难。尽管RAFT（Zhang等，2024c）等方法试图通过提高检索相关性来解决这一问题，但其有效性随着文档长度的增加而逐渐降低。为了克服这些限制，我们设计了一个结构化和紧凑的模板库，旨在高效且准确地检索，特别针对复杂的推理问题。 大语言模型（LLM）推理中的推理扩展 大语言模型的自回归特性表明，解决更复杂的问题本质上需要生成更多的标记。早期的工作，如链式思维（CoT，Wei 等，2022），通过提示技术（例如“让我们一步一步思考”）将复杂的推理任务分解为更简单的子问题，从而提升推理性能。在此基础上，树状思维（ToT，Yao 等，2024）和图状思维（GoT，Besta 等，2024）采用不同的数据结构扩展了推理空间，使大语言模型能够探索多种解决路径。最近的研究（Wu 等，2024；Snell 等，2024）形式化了推理扩展规律的概念，探讨了生成额外标记与使用不同推理策略之间的权衡。例如，多数投票和最佳选择方法（Wang 等，2023；Li 等，2023）生成多个候选解，并根据结果中的频率或奖励模型的评估选择最佳解。类似地，使用蒙特卡洛树搜索（MCTS，Zhang 等，2024b；Liu 等，2024c；Choi 等，2023；Zhou 等，2023）的方法通过更大的搜索和计算量来提高准确性。为了提升搜索精度，过程奖励模型（PRMs）被引入以选择高质量的推理路径，研究（Setlur 等，2024；Snell 等，2024；Lightman 等，2023；Luo 等，2024；Wang 等，2024）证明了其在复杂推理任务中的有效性。最近，诸如思维模板（BoT，Yang 等，2024b）等方法利用过去推理过程中的思维模板来引导探索，显著提高了效率。然而，对于这些基于模板的方法，探索与利用的权衡（Tang 等，2024；Setlur 等，2024）仍是一个未解决的挑战。我们的工作通过扩展一种分层的模板增强推理范式来应对这一挑战，在战略性地平衡探索与利用的同时，显著提升了推理准确性，尤其是在复杂任务中。 ReasonFlux: Scaling Thought Templates for Hierarchical LLM ReasoningConstructing Structured Thought Template Library受到人类在解决复杂推理问题时利用外部资源的启发，RAG方法通过使大型语言模型（LLMs）能够从外部来源检索信息来增强其能力（Zhao等，2024）。最近的“思维缓冲区”（BoT）（Yang等，2024b）尝试为LLM推理创建一个高级思维缓冲区，并构建了一个高效的RAG推理系统。尽管BoT拥有一个全面的模板库来解决类似问题，但随着模板规模的增加，它仍然面临可扩展性挑战，这与依赖嵌入相似性来搜索非结构化文本语料库的传统RAG系统相同。 为了解决这一问题，我们的方法专注于构建一个结构化的思维模板库，以实现更精确、有针对性的检索，并缓解可扩展性挑战。为了构建这个库，我们从不同来源精心挑选了广泛且多样化的具有挑战性的数学推理问题，确保模板库的鲁棒性和广泛适用性。我们使用大语言模型（LLM）分析解决方案背后的思维，生成简洁的问题解决策略摘要，并识别常见模式。这一过程产生了一系列高质量、以解决方案为导向的思维模板。库中的每个模板Ti都经过结构化设计，以便高效检索和应用，其中Tnam是模板名称（例如，“√R2 − x2型三角代换”），Ttag是一组用于基于关键词检索的标签（例如，{“三角代换”，“无理函数优化”}），Tdes是对基本原理和适用场景的描述，Tsco定义了范围，指定了它解决的问题类型，Ta是一系列详细的应用步骤{a1, a2, …, ak}，而Texa是一组展示其应用的示例。整个模板库Dtemp是一组上述思维模板的集合：Dtemp = {T1, T2, …, Tm} (1)，其中m是模板的总数。在此，我们展示了库中一个思维模板的示例。为了简洁起见，以下示例中的某些字段已简化。更多详细示例请参见附录A。 通过利用与每个模板相关的元数据，特别是名称（n）和标签（t），可以快速准确地基于关键词或特定问题特征进行检索，从而实现高效的检索。这种结构化的组织方式，结合丰富的元数据，确保了在任何给定问题下，最相关的模板都能迅速可用。 Hierarchical Reinforcement Learning on Thought Template Trajectory尽管我们的结构化模板库为推理提供了宝贵的资源，但仍需一种有效的方法来利用该库并选择合适的模板以处理特定问题。为此，我们采用分层强化学习进行训练，最终获得了能够有效规划出问题最优思维模板轨迹的ReasonFlux。我们从库中检索并配置一系列相关模板，协助在特定子问题上实例化这些检索到的模板。ReasonFlux充当经验丰富的导航者，提供最优轨迹（表示为Ttraj），使大语言模型能够将抽象的思维模板实例化为具体的顺序问题解决步骤。 基于结构的微调 我们的分层强化学习过程首先利用结构化模板库Dtemp构建一个知识密集型的训练数据集Dtrain。该数据集包含模板名称Tnam、相关标签Ttag、其基本原理的详细描述Tdes以及其适用范围的清晰界定Tsco的多样化示例，这些信息以元组形式（Tnam, Ttag, Tdes, Tsco）从Dtemp中提取。随后，我们在这个数据集Dtrain上对一个基础大语言模型（LLM）进行微调，该模型记为π。这一过程使模型对库中每个模板的结构、内容和预期用途有了基础理解。微调过程由以下优化目标驱动： 其中，目标是在给定模板名称Tnam和标签Ttag的情况下，最大化模型生成正确描述Tdes和范围Tsco的可能性。这确保了微调后的模型能够有效地将模板的标识信息（Tnam和Ttag）与其功能方面（Tdes和Tsco）关联起来。微调后，我们将生成的模型记为πstruct。 基于微调的大型语言模型（LLM）πstruct，我们可以进一步增强其能力，为输入问题x规划出一系列高级思维模板（即思维模板轨迹Ttraj），并将每个步骤与库中最相关的模板关联起来。这是通过我们在思维模板轨迹上的偏好学习实现的。具体来说，如图1所示，给定一个输入问题x，πstruct首先分析并抽象出问题的条件信息，识别出涉及的核心数学概念和关系。基于这种抽象表示，导航器πstruct随后配置一个轨迹Ttraj = {s1, s2, …, sn}，其中每个si代表推理过程中的一个高级步骤，并与从库中检索出的特定模板名称相关联，该模板可用于解决问题，记为Ti。每个检索到的模板Ti随后会用输入问题x的具体细节进行实例化，并为单独推理的LLM（记为πinf）提供细粒度的指导，以解决问题。 为了衡量给定轨迹的有效性和泛化能力，我们使用一组与原始输入问题x相似的问题Xsim，包括x本身。然后，我们使用沿轨迹Ttraj实例化的模板来指导πinf解决每个问题xi ∈ Xsim。πinf在这些问题上的平均准确率作为轨迹奖励R(Ttraj)。形式上： $$R(T_{traj}) = \\frac{1}{|X_{sim}|} \\sum_{x_i \\in X_{sim}} \\text{Acc}(\\pi_{inf}(x_i, T_{traj})) \\quad (3)$$ 其中，$\\text{Acc}(\\pi_{inf}(x_i, T_{traj}))$表示πinf在轨迹Ttraj指导下解决问题xi的准确率。 这个奖励信号随后用于构建优化对，使我们能够进一步优化导航器πstruct。具体来说，对于每个输入问题x，我们采样多个不同的Ttraj，并利用模板轨迹奖励评估其质量。我们定义优化πstruct的损失函数如下： $$L_{TTR}(\\theta) = -\\mathbb{E}{(x, (T^+{traj}, T^-{traj})) \\sim D{pair}} \\left[ \\log \\sigma \\left( \\beta \\log \\frac{\\pi_{\\theta}(T^+{traj}|x)}{\\pi{sft}(T^+{traj}|x)} - \\beta \\log \\frac{\\pi{\\theta}(T^-{traj}|x)}{\\pi{sft}(T^-_{traj}|x)} \\right) \\right] \\quad (4)$$ 其中，$D_{pair}$是优化对的数据集。每对包括一个输入问题x和两个轨迹$T^+{traj}$和$T^-{traj}$，其中$R(T^+{traj}) &gt; R(T^-{traj})$。$\\pi_{\\theta}$表示正在优化的LLM，参数为θ，从πstruct初始化。 Inference Scaling with Scaling Thought Templates在层次化强化学习（RL）过程之后，我们将优化后的导航器πθ称为ReasonFlux。然后，我们进一步设计了一种新颖的推理扩展系统，通过利用自动规划的轨迹和动态检索的思维模板来实现。该系统如图2所示，涉及ReasonFlux、结构化模板库Dtemp和下游推理大语言模型（LLM）πinf之间的多轮交互。给定一个输入问题x，ReasonFlux的首要任务是分析并提取嵌入在x中的核心数学概念和关系。基于这个抽象表示，记为a(x)，ReasonFlux随后配置一个最优模板轨迹T∗ traj。该轨迹表示为一系列步骤T∗ traj = {s1∗, s2∗, …, s∗n}，它不是一个僵化的、预定义的路径，而是一个根据输入问题x的具体细节动态生成的计划。轨迹中的每个步骤s∗ i都与一个特定的模板名称Tnam和Ttag相关联，以便高效检索。ReasonFlux随后从精心策划的思维模板库Dtemp中搜索并检索一组最相关的思维模板。形式上，检索过程可以表示为： $$\\text{Trag} = \\text{ReasonFlux}({T^i_{\\text{nam}}, T^i_{\\text{tag}}}^n_{i=1}, \\text{Dtemp}), \\quad (5)$$ 其中，Trag = {T1, T2, …, Tn}是检索到的n个模板的集合，与配置的轨迹中的步骤数量相等，每个模板都是一个结构化模板。随后，基于T∗ traj和检索到的模板Trag，ReasonFlux将指导πinf实例化每个步骤s∗ i，并结合相应的模板Ti和问题x中的具体细节，转化为具体的实例化推理步骤sˆi： $$\\hat{s}i = \\pi{\\text{inf}}(x_i, s_i, T_i), \\quad (6)$$ 其中，每个sˆi是基于相应的s∗ i、Ti和x生成的。ReasonFlux和πinf之间的交互不是单向的，而是以迭代的方式进行。在获得实例化步骤sˆi后，ReasonFlux会对其进行评估和分析，我们将这一调整过程表示为δi = ReasonFlux(T∗ traj, sˆi)。基于这一评估结果和分析，ReasonFlux决定是否优化轨迹，可能会调整后续步骤，甚至检索替代模板。这种迭代优化可以表示为： $$T^_{\\text{traj}} \\leftarrow \\text{ReasonFlux}(T^_{\\text{traj}}, \\delta_i). \\quad (7)$$ ReasonFlux和πinf之间的这种迭代反馈机制强调了复杂问题解决中的一个关键方面：规划与执行之间的动态交互。通过分析推理过程中生成的中间结果，ReasonFlux获得了有价值的见解，可以为轨迹的调整提供信息。这种优化解决方案路径的能力精确地反映了人类如何通过检查部分结果来发现更高效或更有效的解决方案。此外，中间步骤可能会揭示问题中先前被掩盖的约束或机会，从而允许采用更明智和有针对性的方法。因此，ReasonFlux的层次化特性，通过这种迭代优化得以实现，对于导航复杂推理任务并实现最优解决方案至关重要。总之，ReasonFlux通过根据问题复杂性动态配置和调整模板轨迹，实现了有效的问题解决，超越了传统推理方法的局限性，提供了一个更高效和强大的推理框架。 Experiments直接看图就好，总结下来就是赢赢赢！ Conclusion在这项工作中，我们提出了ReasonFlux，一种新的分层LLM推理框架，它自适应地扩展基本和必要的思维模板，以简化复杂推理的搜索空间，并在数学推理能力上超越了强大的LLM，如OpenAI o1-preview和DeepSeek V3。我们引入了一个结构化和紧凑的思维模板库、思维模板轨迹上的分层强化学习以及一个全新的推理扩展系统。在不同具有挑战性的数学基准上的广泛实验证明了ReasonFlux的优越性。我们还揭示了一些关键发现，包括我们模板增强推理的扩展规律，以及ReasonFlux在探索-利用权衡上相较于以往推理策略的优越性。 版权声明：本文为原创，转载请注明出处。","link":"/2025/05/11/Research/ReasonFlux%EF%BC%9A%20Hierarchical%20LLM%20Reasoning%20via%20Scaling%20Thought%20Templates/"},{"title":"SUPERCORRECT：SUPERVISING AND CORRECTING  LANGUAGE MODELS WITH ERROR-DRIVEN INSIGHTS","text":"单位： Peking University, National University of Singapore, UC Berkeley, Stanford University代码：https://github.com/YangLing0818/SuperCorrect-llm基座模型： Qwen2.5-Math-7B, Meta-Llama3.1-8B, DeepSeek-Math-7B原文地址：https://arxiv.org/pdf/2410.09008显卡：8 * NVIDIA A100-PCIE-40GB GPU 总结 我们将我们的贡献总结如下：(i) 我们提出了一种新颖的两阶段微调方法SUPERCORRECT，用于提高大型语言模型（LLMs）的推理准确性和自我纠正能力。(ii) 我们提出了基于层次化思维的微调方法，使小型LLMs能够生成更准确和细粒度的推理思维。(iii) 我们提出了跨模型协作的DPO（Distributed Policy Optimization），创新性地利用最先进的LLMs来定位和纠正较小学生LLMs在推理过程中的特定错误思维，从而提升其自我纠正能力并突破其思维瓶颈。(iv) 我们构建了两个高质量的数据集，并开发了三个强大的推理LLMs：SUPERCORRECT-Qwen/DeepSeek/Llama-7B，在MATH数据集上达到了70.2%的准确率，在GSM8K数据集上达到了89.5%的准确率，在所有7B模型中创造了新的SOTA（State-of-the-Art）性能。 abstract大型语言模型（LLMs）如GPT-4、PaLM和LLaMA在各种推理任务中展示了显著的改进。然而，较小的模型如Llama-3-8B和DeepSeekMath-Base在复杂的数学推理方面仍然存在困难，因为它们无法有效地识别和纠正推理错误。最近的基于反思的方法旨在通过启用自我反思和自我纠正来解决这些问题，但它们仍然面临在独立检测推理步骤中的错误方面的挑战。为了克服这些限制，我们提出了SUPERCORRECT，一个新颖的两阶段框架，该框架使用一个大型教师模型来监督和纠正较小学生模型的推理和反思过程。在第一阶段，我们从教师模型中提取层次化的高级和详细思维模板，以指导学生模型引出更细粒度的推理思维。在第二阶段，我们引入了跨模型协作直接偏好优化（DPO），通过在训练过程中跟随教师的纠正轨迹来增强学生模型的自我纠正能力。这种跨模型DPO方法教导学生模型有效地定位和解决错误思维，通过从教师模型获得的错误驱动洞察力，打破其思维瓶颈，并获取新技能和知识以应对具有挑战性的问题。广泛的实验一致证明了我们相对于先前方法的优越性。值得注意的是，我们的SUPERCORRECT-7B模型在MATH/GSM8K基准测试中显著超越了强大的DeepSeekMath7B和Qwen2.5-Math-7B，分别提高了7.8%/5.3%和15.1%/6.3%，在所有7B模型中实现了新的SOTA性能。 INTRODUCTION大型语言模型（LLMs）（Brown等，2020；Anil等，2023；Achiam等，2023；Du等，2022；Jiang等，2024），如GPT-4（Achiam等，2023）、PaLM（Anil等，2023）和LLaMA（Touvron等，2023a；b），在各种推理任务中展示了显著的改进。然而，尽管这些模型在大规模数学数据集上使用多种技术进行了预训练，较小的模型如Llama-3-8B（Dubey等，2024）和DeepSeekMath-Base（Shao等，2024）在复杂的数学推理任务中仍然表现不佳。 现有的研究旨在通过各种方法提升LLMs的数学性能。我们将这些方法分为两类：传统的微调优化和基于反思的优化。传统的微调方法主要探索训练技术，如监督微调（SFT）（Roziere等，2023；Shao等，2024；Dubey等，2024），以及LLM对齐策略，如基于人类反馈的强化学习（RLHF）（Achiam等，2023；Ouyang等，2022；Bai等，2022a；b）和替代方法，如直接偏好优化（DPO）（Rafailov等，2024）。尽管这些方法在广泛的语言任务中展示了显著的进展，但它们的优化目标仅集中在直接答案或简单的推理逻辑上。因此，它们在定位推理过程中的错误和修正语言模型的错误推理逻辑方面存在困难。 最近的基于反思的方法试图解决微调方法的不足，并利用预先设计的提示或通用规则来指导语言模型在推理过程中进行自我反思和自我纠正（Shinn等，2024；Kim等，2024）。一些方法（Li等，2023；2024c）进一步利用大语言模型（LLMs）合成基于规则的数据集，以增强其在训练阶段的自我纠正能力。然而，正如Tyen等（2024）所提到的，LLMs仍然难以独立识别其推理步骤中的错误。如果没有准确的错误识别，自我纠正将变得更加困难。在复杂的数学推理中，即使提供了错误的位置，LLMs仍然常常受到其先前推理背景的偏见或误导。因此，语言模型在单一LLM内澄清推理错误的原因仍然具有挑战性。 为了解决这些局限性，我们提出了一种新颖的两阶段框架，即SUPERCORRECT，利用大型教师模型的思维来监督和纠正较小学生模型的推理和反思过程。如图1所示，在第一阶段，我们从教师LLM中提取层次化的思维模板，以指导学生模型生成更细粒度的推理思维。该模板包含一个高级思维，为类似问题提供总结性和概括性的解决方案，以及一个详细解决方案，提供关键推理步骤的详细解释。与之前的思维格式（如CoT（Wei等，2022）和BoT（Yang等，2024b））相比，我们的层次化思维模板为后续的错误纠正提供了更深层次和更具信息量的推理见解。在第二阶段，我们提出了跨模型协作的DPO（Direct Preference Optimization）来优化学生模型，并通过在训练过程中遵循教师的跨模型纠正轨迹来增强其自我纠正能力。具体来说，我们不仅模拟正确答案或首选的推理过程，还指导教师LLM识别并纠正学生思维中的错误部分。然后，这种跨模型纠正轨迹被用来指导学生模型进行更好的自我纠正，使其能够避免并纠正特定的错误。我们跨模型DPO方法的关键见解是使学生语言模型能够突破其思维的瓶颈，并从教师的纠正轨迹中获得新的错误驱动的见解和知识。 此外，我们构建了一个高质量的精调数据集，配备了包含10万个样本的分层思维模板，以及一个用于思维级校正优化的成对偏好数据集，包含1万个样本。该数据集由以下部分组成：1）一个数学问题，2）按照我们预先设计的格式编写的先前推理步骤，3）由教师大语言模型基于真实解生成的带有选定分析和校正指导的步骤，4）由学生大语言模型在没有访问真实解的情况下生成的带有拒绝分析和校正指导的步骤。 我们将我们的贡献总结如下：(i) 我们提出了一种新颖的两阶段微调方法SUPERCORRECT，用于提高大型语言模型（LLMs）的推理准确性和自我纠正能力。(ii) 我们提出了基于层次化思维的微调方法，使小型LLMs能够生成更准确和细粒度的推理思维。(iii) 我们提出了跨模型协作的DPO（Distributed Policy Optimization），创新性地利用最先进的LLMs来定位和纠正较小学生LLMs在推理过程中的特定错误思维，从而提升其自我纠正能力并突破其思维瓶颈。(iv) 我们构建了两个高质量的数据集，并开发了三个强大的推理LLMs：SUPERCORRECT-Qwen/DeepSeek/Llama-7B，在MATH数据集上达到了70.2%的准确率，在GSM8K数据集上达到了89.5%的准确率，在所有7B模型中创造了新的SOTA（State-of-the-Art）性能。 RELATED WORK基于人类反馈的强化学习用于大型语言模型 为了提高大型语言模型（LLMs）的性能和可靠性，引入了基于人类反馈的强化学习（RLHF）方法，如Christiano等人（2017）和Ouyang等人（2022）的研究，用于LLM的对齐。这种方法对数据集的要求更高，因为它需要成对的标注数据来训练奖励模型，从而反映人类偏好。然后使用强化学习训练策略模型，以最大化估计的奖励。尽管这种方法被证明是有效的，但由于其对奖励模型质量的依赖，这一过程复杂且计算密集。为了简化这一过程，Rafailov等人（2024）提出了直接偏好优化（DPO），它直接使用成对数据进行优化。通过将偏好损失定义为策略的函数，DPO可以使用简单的训练技术优化策略，避免了强化学习的复杂性。然而，由于优化单元的设计，当前方法在数学推理方面仅显示出有限的改进。Lai等人（2024）的工作通过将每个中间推理步骤视为基本单元，建立了更细粒度的奖励单元。然而，它们未能明确错误原因并提供纠正错误的明确指导。在本文中，我们特别设计了一种基于跨模型师生协作思维的奖励机制，将每个纠正步骤作为基本优化单元。 自我纠正/反思推理 自我纠正在提升大语言模型（LLM）输出的风格和质量方面显示出潜力。先前的研究（Li et al., 2023; Shinn et al., 2024; Madaan et al., 2024; Saunders et al., 2022; Miao et al., 2023; Chen et al., 2023a）聚焦于自我纠正的概念，即让LLM纠正其自身的输出。然而，正如Huang等人（2023）所提到的，尽管自我纠正在提升模型输出的风格和质量方面可能有效，但在推理任务中，LLM在没有外部反馈的情况下难以识别和修正错误。例如，Reflexion（Shinn et al., 2024）和RCI（Kim et al., 2024）都使用真实正确性作为信号来停止自我纠正循环。此外，一些尝试自我纠正逻辑或推理错误的努力有时会将正确答案变为错误答案，导致整体表现更差（Huang et al., 2023）。虽然先前的研究通常将自我纠正描述为在特定LLM内部进行的过程，但我们的方法利用大规模LLM来明确识别错误并从错误中获取纠正见解。通过这种跨模型奖励，我们可以通过微调和基于纠正的偏好优化来修正小型LLM在推理任务中暴露的弱点。 数学推理中的思维扩展 数学推理中的思维扩展主要关注预设计的推理结构或模板，利用提示技术来增强大语言模型（LLMs）的数学推理能力。链式思维（Chain-of-Thought, CoT）提示（Wei等，2022）及其变体（Kojima等，2022；Press等，2023；Arora等，2022），如最少到最多（Least-to-Most, Zhou等，2022）、分解提示（Decomposed Prompting, Khot等，2022）和自动CoT（Auto-CoT, Zhang等，2022），提示LLMs将复杂问题分解为更简单的子任务，并系统地解决它们，最后总结出最终答案。像树状思维（Tree-of-Thought, Yao等，2024）和图状思维（Graph-of-Thought, Besta等，2024）这样的创新进一步复杂化了这一领域，通过探索动态、非线性的推理路径来扩展LLMs的启发式能力（Chen等，2023b；Ning等，2023）。其他方法如PoT（Chen等，2022）、PAL（Gao等，2023b）和Gou等（2023）尝试利用外部工具（如代码）来避免LLMs在数学推理过程中的幻觉。然而，这些方法存在资源需求增加、时间复杂性更高、依赖手动提示设计，并且通常针对特定任务类型的问题。最近的BoT（Yang等，2024b）提出了一种任务无关的范式，通过元缓冲区基于累积的思维模板高效解决问题。然而，这是一个无需训练的框架，可能无法本质上提升LLMs的推理能力。为了进一步提升LLMs的内部推理能力，Quiet-STaR（Zelikman等，2024）使用基于RLHF的自我教学，通过LLMs自我生成的思维来改进普通任务和简单数学问题的推理。对于超出学生能力的更复杂问题，这种“先思考后推理”的模式可能效果不佳。在本文中，我们利用一种新的跨模型范式，使LLMs能够从外部模型反馈中提升推理和自我纠正能力，从而打破LLMs原始思维的瓶颈，拓宽模型解决更广泛问题的能力。 PRELIMINARY基于人类反馈的强化学习 基于人类反馈的强化学习（Reinforcement Learning from Human Feedback, RLHF）（Christiano et al., 2017）是一种有效的方法，用于增强大语言模型（LLMs）的鲁棒性、事实性和安全性（Ouyang et al., 2022）。RLHF包含三个训练阶段：1）监督微调（SFT）；2）奖励模型训练；3）策略模型微调。 监督微调阶段：RLHF通常从对预训练语言模型进行监督微调开始，使用高质量数据针对下游任务（如对话、摘要等）进行训练，以获得模型πsft。 奖励模型训练阶段：对于任何文本，奖励模型会为最后一个标记分配一个标量奖励值，奖励值越大，样本质量越高。根据Stiennon等人（2020）的研究，训练奖励模型通常使用由同一输入生成的两个响应对比组成的数据集。每对偏好样本和非偏好样本的建模损失为： 其中σ为Sigmoid函数，r表示参数为ψ的奖励模型，r(x, y)是输入提示x和响应y的预测奖励标量值。然而，由于训练流程复杂，这种方法通常被认为较为复杂。 强化学习微调阶段：在强化学习阶段，学习到的奖励函数用于为语言模型提供反馈。根据先前的研究（Tutor; Jaques et al., 2020），优化目标被表述为： 其中β是控制与基础参考策略πref（即初始SFT模型πsft）偏离程度的参数。在实践中，语言模型策略πθ也初始化为πsft。由于语言生成的离散性，该目标不可微分，通常通过强化学习进行优化。标准方法（Ziegler et al., 2019; Bai et al., 2022a; Ouyang et al., 2022）是构建如公式（1）所示的奖励函数，并使用PPO（Schulman et al., 2017）进行最大化。 Direct Preference Optimization (DPO) 是一种与传统RLHF方法竞争的替代方案，由Rafailov等人于2024年提出，旨在直接利用成对偏好来优化策略模型，并具有等效的优化目标。具体来说，给定一个输入提示x和一个偏好数据对(y+, y−)，DPO的目标是最大化优选输出y+的概率，并最小化不理想输出y−的概率。优化目标公式为： $$L_{DPO}(\\theta) = -\\mathbb{E}{(x,y+,y−)\\sim D}\\left[\\log \\sigma\\left(\\beta \\log \\frac{\\pi\\theta(y+|x)}{\\pi_{\\text{ref}}(y+|x)} - \\beta \\log \\frac{\\pi_\\theta(y−|x)}{\\pi_{\\text{ref}}(y−|x)}\\right)\\right], $$ 其中，$$D$$是成对偏好数据集，$$σ$$是sigmoid函数，$${\\pi_\\theta(·|x)}$$是要优化的策略模型，$${\\pi_{ref}(·|x)}$$是在训练期间保持不变的参考模型，超参数β控制与参考模型的距离。 METHODSUPERVISED FINE-TUNING WITH HIERARCHICAL THOUGHT TEMPLATE构建从教师大语言模型（LLMs）中提取的分层思维模板。传统的用于训练LLMs的指令-响应数据集（Ouyang等，2022年）主要关注响应的正确性，导致LLMs仅仅模拟提供的解决方案和答案，而忽略了中间推理思维的重要性。最近的工作如BoT（Yang等，2024b）利用高级推理指南（思维模板）使LLMs能够以无需训练的方式有效解决类似问题。然而，对于复杂且多样的数学推理任务，我们发现仅使用高级思维模板是不够的，特别是对于小型LLMs。为了使小型LLMs能够处理复杂的推理任务，我们特别设计了一种从大型教师LLMs中提取的分层思维模板，用于转移到小型学生LLMs。这种新的分层思维模板包括高级思维和详细解决方案。前者为类似问题提供了总结和概括的解决方案，而后者则提供了关键推理步骤的详细解释。 基于这个层次化思维模板，我们可以提出一个新的微调目标，旨在将类似人类的层次化问题解决思维结构融入模型推理中，并在推理过程中显式地生成层次化思维。我们首先收集一组数学问题 $$D = {(x, \\hat{y}, \\hat{s})$$ ，其中 $$$$ 是问题， $$\\hat{y$$ 是正确答案， $$\\hat{s$$ 是解决方案。对于每个问题 $$x \\in $$ ，我们首先使用预定义的提示 $$P_{\\text{tea}$$ （如下文所示）从教师大语言模型（例如，像 o1-preview/o1-mini 这样的 SOTA 大语言模型）中提取层次化思维模板。关于我们的提示的更多细节，我们在附录 A 中提供了所有提示。 然后我们可以获得高质量的精调数据集 $$D_{sft$$ 如下： $$D_{sft} = \\pi_{tea}(P_{tea}, x, \\hat{s}) = {x, s_{tea}, T_{tea}, y_{tea} | x \\in D}, \\quad (4) $$ 其中 $$s_{tea$$ 是形式化的解题步骤， $$T_{tea$$ 是解题的层次化思路， $$y_{tea$$ 是从 $$s_{tea$$ 中提取的最终答案。以下我们提供了一个层次化思路模板的示例。对于普通和简单的步骤，我们提供简要的解释和直接的解法；而对于复杂和困难的推理步骤，我们在 $$\\langle Key \\rangl$$ 中提供详细的解法和深入的解释，以帮助学生大语言模型更好地理解其中的深层思想。此外，我们在 $$\\langle Generalized \\rangl$$ 中提供高层次思路作为通用指导，帮助高效解决类似问题。 基于思维的有监督微调 在整理好我们的基于思维的数据集Dsft后，我们的优化目标是使学生大语言模型π能够通过分层思维进行推理，并对每个问题解决过程有更全面的理解，这可以表示为： 从基础的学生大语言模型π开始，$$L_{sft}$$最大化在给定提示$$P_{stu}$$和输入问题x的情况下响应$$(T_{tea}, s_{tea})$$的可能性，其中$$P_{stu}$$表示预定义的提示$$P_{tea}$$。在微调过程之后，我们通过从最先进的推理大语言模型中学习分层思维，极大地增强了基础学生大语言模型的推理能力，并使学生大语言模型能够生成类似的分层思维以及最终答案。然后，我们获得了微调后的学生大语言模型πref，可用于第4.2节中的跨模型协作dpo。 CROSS-MODEL COLLABORATIVE DPOBoosting DPO with Thought Correction 虽然DPO在某些领域（如聊天、风格等）表现出色，但其优化目标在处理复杂的数学推理任务时效果不佳。Lai等人（2024）指出，问题在于解决复杂数学问题时，错误往往出现在最具挑战性的步骤（如复杂的计算、巧妙的变换）。这可能导致训练过程中错误的优化，因为即使前面的步骤是正确的，也会被拒绝。此外，单个大型语言模型（LLM）很难检测和纠正自身的错误（Tyen等人，2024）。这类似于学生难以从自己的错误解答中获得洞察。错误的根源在于有缺陷的推理，仅仅模仿正确的解决方案而不解决思维层面的错误是低效的。为了解决这个问题，我们精心设计了新颖且细粒度的优化目标，优先考虑思维层面的纠正，而非传统的实例层面的偏好。具体而言，我们首先准确定位错误步骤，然后使用该错误步骤的纠正轨迹作为优化单元。这种方法优先选择来自教师大语言模型（πtea）的跨模型纠正轨迹，而非来自学生大语言模型（πref）的自我纠正轨迹，从而增强学生大语言模型的错误检测和自我纠正能力。 为了实现思维层面的纠正，我们需要收集一个包含细粒度自我和交叉纠正轨迹配对数据的数据集。具体来说，我们利用微调后的学生大语言模型$${\\pi_{ref}}$$在我们采样的测试数据集$$D_{test} = {x_{test}, \\hat{y}{test}, \\hat{s}{test}}$$上进行基于思维的推理，并得到测试结果$$\\pi_{\\text{sft}}(x_{\\text{test}}) = {x_{\\text{test}}, s_{\\text{test}}, T_{\\text{test}}, y_{\\text{test}} \\mid x_{\\text{test}} \\in D_{\\text{test}}}.$$。通过过滤掉满足$$ y_{\\text{test}} \\neq y_{\\hat{t}\\text{est}} $$的错误问题-解决对，最终得到错误数据集：$$D_{\\text{err}} = {x_{\\text{test}}, \\hat{y}{\\text{test}}, \\hat{s}{\\text{test}}, s_{\\text{err}}, T_{\\text{err}}, y_{\\text{err}} \\mid x_{\\text{test}} \\in D_{\\text{test}}}.$$，其中serr是错误解决方案，$$T_{\\text{err}}$$是相应的错误思维，$$y_{\\text{err}}$$是从$$s_{\\text{err}}$$中提取的错误答案。 给定每个错误的解决方案都明确地表示为一系列推理步骤 $$s_{err} = s_1, s_2, \\ldots, s_$$ ，我们继续验证每个推理步骤的正确性，直到找到第一个错误并记录其步骤编号 $$$$ 。在这里，我们利用当前强大的模型（例如，gpt-4o, o1-mini）在数学推理中作为经验丰富的教师模型 $$\\pi_{tea$$ 。为了获得相应的错误步骤和原因分析，我们设计了一个提示 $$P_$$ 来指导 $$\\pi_{tea$$ 在提供的推理步骤中搜索逻辑缺陷和错误。在搜索 $$s_{err$$ 并评估每个推理步骤后，我们可以定位每个错误步骤，并用错误原因分析 $$a_$$ 和修正指导 $$c_$$ 对每个错误步骤进行注释。因此，我们可以获得一个成对自我和交叉修正的注释数据集： $$D_{corr} = {(x, {s_i}_{i=0}^{k-1}, (a^+_k, c^+_k), (a^-_k, c^-k)) | x \\in D{err}$$ ，其中 $$$$ 表示第一个错误步骤。这里 $$(a^+_k, c^+_k$$ 被选为教师模型的修正步骤和分析， $$(a^-_k, c^-_k$$ 被选为学生模型的拒绝修正步骤和原因分析，使用与教师相同的修正提示。为了进一步确保我们数据集的质量，我们还提出了一个检查器 LLM 来进行迭代评估，通过将其与输入问题和真实解决方案进行比较来验证修正轨迹的准确性。如果检测到问题，有问题的部分将被发送回教师 LLM 进行修订。这个迭代检查过程将持续到没有错误为止，最多允许三次迭代。在我们的实现中，我们在 HSFT 数据集的整理过程和成对自我和修正数据集中都应用了检查器 LLM。更多细节请参阅第 5.5 节，我们还在第 5.5.2 节中对数据集质量进行了详细分析。 在第二阶段的我们的方法中，我们提出的跨模型协作DPO利用教师LLM的跨模型校正来增强学生LLM的错误检测和自我校正能力。如公式（7）所述，前k-1个正确的推理步骤$${si}^{k−1}_{i=0}$$与输入问题x结合，我们的跨模型协作DPO旨在最大化教师LLM对错误步骤（a+ k , c+ k）的校正和分析的概率，同时最小化学生LLM的自我校正和分析（a− k , c− k）的概率。我们的跨模型协作DPO的优化目标可以表述为： 通过优先考虑跨模型校正而非自我校正，如图2所示，我们的方法帮助学生模型准确定位数学推理过程中的错误步骤，并有效地进行自我校正。此外，这一过程还帮助学生LLM纠正其原本有缺陷的思维，避免特定错误，从而提高推理能力并减轻幻觉问题。 EXPERIMENTSEXPERIMENTAL SETUP基础模型、数据集与评估: 我们将SUPERCORRECT应用于不同的基础模型，以展示其泛化能力，并取得了新的SOTA（当前最优）结果，包括近期表现强大的Qwen2.5-Math-7B（Yang等，2024a）、Meta-Llama3.1-8B（Dubey等，2024）和DeepSeek-Math-7B（Liu等，2024）。这些模型已被公认为在较小规模下具有高效的推理能力，尤其在数学问题上表现突出。在监督微调（SFT）阶段，我们使用了来自Math数据集（Hendrycks等，2021）训练集的7500道具有挑战性的竞赛数学题，以及来自GSM8K数据集（Cobbe等，2021）训练集的7473道高质量、语言多样的小学数学应用题。此外，我们还从GaoKao Bench（Zhang等，2023）中翻译了670道基于2010-2022年中国高考的数学难题。为了进一步丰富数据集的多样性，我们从NuminaMath（Li等，2024b）和MetaMath（Yu等，2023）中抽取了一些具有挑战性的题目。为了与我们的分层思维推理过程保持一致，我们利用SOTA大语言模型o1-mini/gpt-4o-mini，基于真实解生成了分层思维，并构建了一个基于分层思维的数据集。在跨模型DPO（直接偏好优化）阶段，我们从三个不同的SFT模型中收集了2万条错误推理结果，并按照第4.2节所述进行处理。在评估阶段，我们使用了MATH（Hendrycks等，2021）和GSM8K（Cobbe等，2021）数据集的测试集，并利用开源评估框架（Gao等，2023a）测试了链式思维推理的准确性。 实现细节 我们在8块NVIDIA A100-PCIE-40GB GPU上进行实验。为简洁起见，我们将基于层次化思维的监督微调称为HSFT。首先，我们利用100K HSFT数据对基础模型进行层次化思维监督微调，以获得HSFT模型。所有模型均训练4个epoch，训练批量大小设置为8，梯度累积步数设置为16。学习率设置为2e-5，并使用AdamW优化器以及余弦学习率调度器。预热比例设置为0.02，并使用flash-attention（Dao等，2022）以节省GPU内存。随后，我们在HSFT模型的基础上进行跨模型DPO（Direct Preference Optimization）。对于跨模型DPO，我们训练8个epoch，全局批量大小为128，学习率为1 × 10^−6。同样使用AdamW优化器和余弦学习率调度器，预热比例设置为0.05。 MAIN RESULTS提升推理准确性 如表1所示，我们的方法在所有7B模型中实现了新的SOTA性能，在MATH基准测试中显著超越了强大的DeepSeekMath-7B 7.8%和Qwen2.5-Math-7B 15.1%。这一有希望的结果证明了我们在处理复杂推理任务方面的优越性和有效性。值得注意的是，我们可以在GSM8K和MATH数据集上取得比更大规模的模型（如Llama370B-Instruct，Touvron等，2023a）更好的结果，并且使用我们最好的模型SUPERCORRECT-Qwen-7B可以达到与GPT-4o和GPT-4o-mini相当的准确率。我们将这种推理准确率的提升归因于两个方面：1）第一个HSFT阶段，它为学生LLM配备了更深层次和更细粒度的推理过程。与传统的CoT推理过程相比，它帮助学生LLM更仔细地思考，从而提高了推理的一致性，并减少了在学生LLM已经掌握的问题上的幻觉问题。2）第二个跨模型DPO阶段，它利用教师LLM的错误驱动洞察力，帮助学生LLM打破思维的瓶颈，从而使其能够处理那些学生LLM在获取技能和知识时以前无法解决的问题。我们还在附录B中展示了一些来自不同数据集的层次推理的详细示例，请查看它们以全面了解我们的SUPERCORRECT。 在这里，我们还展示了我们的SUPERCORRECT在自我纠正能力方面的改进，如图3所示。在初始推理阶段之后，我们让所有的大型语言模型（LLMs）验证推理过程，并检测每个推理步骤中的逻辑缺陷和错误，并尝试纠正它们。由于自我纠正的结果，我们的SUPERCORRECT进一步将准确率提高了5∼6%，而其他LLMs在提高准确率方面无效，甚至有些LLMs还降低了原有的准确率。这是因为我们的跨模型DPO通过学习教师的纠正轨迹，帮助LLMs准确定位每个步骤中的错误和逻辑缺陷，并使用细粒度的分析和纠正来帮助LLMs更好地纠正它们。在跨模型DPO过程之后，LLMs不仅能够在其能力范围内一致地解决问题，而且还能够通过从教师LLMs获得的错误驱动洞察力解决更广泛的问题。我们在表6中提供了更多关于跨模型DPO如何使学生模型和教师模型更接近的定量分析。我们还提供了来自不同数据集的一些自我纠正示例，更多详情请查看附录C。 消融研究 我们对我们的SUPERCORRECT进行了消融研究，并将结果展示在表2中。正如我们所看到的，传统的SFT（监督微调）的改进有限，与我们的HSFT（分层监督微调）相比，准确率落后了5%。基于我们的HSFT模型，我们进一步应用了一些自校正方法，如Reflexion（Shinn等人，2024），与我们的Cross-DPO（交叉模型直接偏好优化）进行比较。从结果中可以看出，我们的方法再次胜出，与Reflexion相比，准确率领先了7%。这些令人鼓舞的结果证明了我们的HSFT和交叉模型DPO的有效性。为了更好地理解我们有效的分层思维推理，我们在第5.3节的表3中提供了一个说明性示例。CoT（链式思维）提示方法显示出对“空集”的误解，因为它未能考虑到512个集合已经包含了空集。通过我们基于分层思维的推理（在附录A中表示为HT），我们可以看到模型意识到512个集合包含了空集。然而，它未能正确回忆起问题要求将空集包含在最终答案中，这是由于幻觉问题导致的。最终，我们的HSFT大语言模型能够正确解决这个问题，准确理解空集并避免幻觉问题。 SupperCorrect 打破思维瓶颈 MATH 数据集中的问题涵盖了七个广泛的主题，包括代数、计数与概率、中级代数、数论、几何、初等代数和预微积分。在我们的实验中，我们观察到每个主题的准确性差异较大。对于大多数大型语言模型（LLMs）来说，它们在代数和初等代数上表现较好，但在其他主题上，准确性往往有所下降，这可能是因为它们在这些主题上存在思维瓶颈。如图4所示，我们的SUPPERCORRECT在所有主题上都提高了推理性能。值得注意的是，对于那些原本对LLMs来说较难的主题，SUPPERCORRECT 表现出了更显著的改进，相比于模型已经掌握的主题。这是因为我们在跨模型DPO阶段利用了错误驱动的洞察力，打破了LLMs原有的思维瓶颈，从而启发它们使用新的技巧和方法来解决以前无法解决的问题。结果进一步证明，我们的SUPPERCORRECT 能够帮助打破原有的思维瓶颈，显著提高LLMs的推理能力，并缩小不同主题之间的性能差距。更多详细的推理和自我纠正结果可以在附录B和附录C中找到。 SuperCorrect在推理稳定性方面表现更佳。MATH数据集的测试集包含5000个问题，分为5个不同的难度级别。为了进一步评估我们方法的推理稳定性，我们从MATH测试数据集中额外抽取了300个难度级别为5（最难）的问题。我们通过重复实验256次进行定量分析，并计算了准确率的均值和方差，如图5所示。我们可以观察到，与基础模型相比，我们的SUPERCORRECT方法有助于实现更高的准确率均值。此外，我们的SUPERCORRECT方法显著降低了多次推理的准确率分布的方差。这些现象表明，我们的SUPERCORRECT方法能够有效提高困难推理问题的 DETAILED QUALITATIVE ANALYSIS详细的定性分析 在本节中，我们对三种不同方法（包括CoT提示、我们第一阶段HSFT模型和我们的SUPERCORRECT）在易错推理步骤和推理结果方面进行了详细的比较。 COMPARISON BETWEEN STEP-DPO AND CROSS-MODEL DPO我们进行了Step-DPO与我们的Cross-model DPO之间的定性分析。我们选择Qwen2.5-Math-Instruct作为基础模型，并在该模型上应用Step-DPO以比较结果。需要注意的是，Step-DPO使用了CoT风格的提示，为了公平比较，我们为每个模型选择了最合适的提示方法。如表4所示，基于之前未解决的问题，Step-DPO能够定位错误的推理步骤并进行修正（例如，进一步识别另一个7的倍数），但它难以完全纠正这些错误。与Step-DPO相比，我们的方法不仅能够定位错误步骤，还能进行准确的自我修正，从而解决之前无法解决的问题。 QUALITY EVALUATION FOR TEACHER LLM GENERATED CONTENT5.5.1 检查者LLM的评估 我们讨论了检查者LLM的有效性，它进一步确保了教师LLM生成内容的质量。如表5所示，我们比较了三种不同教师LLM在三个数据集上生成的修正轨迹的正确性。与直接生成相比，应用检查者LLM显著提高了最终修正轨迹的质量。值得注意的是，对于已经能够生成高质量输出的具备先进能力的LLM，检查者LLM仍然显示出明显的改进。这些结果表明，检查者LLM显著提高了修正轨迹的准确性，尤其是在初始性能较低的数据集上 5.5.2 直接生成质量分析 根据表5中的结果，在没有使用Inspector LLM的情况下，实验结果表明我们直接生成的修正轨迹已经具有较高的质量。我们将此归因于以下设计方法： 1. 利用前沿教师LLM：为了确保教师LLM生成内容的质量，我们采用了最先进的LLM，特别是o1-mini作为教师LLM。这些模型能够识别逻辑缺陷和错误，并生成高质量的分析和修正，定量结果也证实了这一点。 2. 基于真实上下文的修正轨迹：为了确保教师LLM生成的修正轨迹的准确性，如附录A所示，生成分析（ai）和修正（ci）的提示基于输入问题及其真实解决方案。这种方法将修正轨迹与真实解决方案作为上下文相结合，从而确保生成内容的准确性。 MORE ABLATION STUDIES关于跨模型DPO的进一步分析，我们首先从数据集中抽取了500个错误解决方案，并使用o1-mini对数据集进行修正追踪，以此作为衡量模型对齐的基准。我们在HSFT阶段后对三个不同模型进行了实验，结果如表6所示。为了评估跨模型DPO的有效性，我们引入了两个指标：(1) 定位正确性：表示模型是否能够正确找到错误步骤。(2) 修正准确性：表示模型是否能够准确修正错误步骤。我们利用o1-preview作为评判工具，将跨模型DPO后各模型生成的修正追踪与基准进行比较。结果表明，跨模型DPO在所有模型上均显示出显著改进，证明了其有效性。 如表7所示，消融研究结果表明，我们的SuperCorrect方法能够泛化到不同的LLM架构，并在HSFT阶段和跨模型DPO阶段均表现出更优的性能，进一步验证了其有效性。 关于提示风格的消融研究 为了进一步评估我们精心设计的层次化思维模板的有效性，我们进行了定量实验，以展示提示风格和我们的层次化提示设计的影响。我们使用了五种提示风格：1) 思维链（CoT）；2) 思维链 + 层次化提示（无泛化步骤）；3) 思维链 + 层次化提示（含泛化步骤）；4) 我们的层次化提示（非XML格式）；5) 我们的层次化提示（XML格式）。此外，我们基于相同的10万道数学问题，为前四种提示风格构建了四个数据集。随后，我们在相同的训练设置下，使用这些数据集训练了Qwen2.5-Math-Instruct、Llama3.1-8B-Instruct和DeepSeek-Math-7B模型，并在数学数据集上评估了准确性。如表8所示，实验结果表明，与使用思维链作为基线相比，层次化推理显著提高了模型的准确性。此外，改变提示风格（例如转换为XML格式）对最终准确性的影响较小，进一步证明了我们层次化推理设计的有效性。尽管添加泛化步骤有助于模型更好地总结任务并提升其性能，但我们的实验结果表明，在HSFT阶段，性能提升的主要贡献来自于我们设计的层次化推理风格。 CONCLUSION在这篇论文中，我们提出了SUPERCORRECT，一个新颖的两阶段框架，显著改进了语言模型的推理和反思过程。在SUPERCORRECT中，我们提出了基于层次思维的微调方法，使大语言模型（LLMs）能够生成更细粒度的推理思维，并引入了跨模型协作的DPO（Direct Preference Optimization）方法，通过跟随教师的修正轨迹来增强学生LLMs的自我修正能力。大量的实验一致证明了我们的方法相较于之前方法的优越性，在MATH和GSM8K基准测试中，分别超越了强大的DeepSeekMath-7B模型5.3%∼7.8%和Qwen2.5-Math-7B模型6.3%∼15.1%。在未来的工作中，我们将把这个新框架推广到更大的模型和更复杂的数据集上。 版权声明：本文为原创，转载请注明出处。","link":"/2025/05/31/Research/SUPERCORRECT%EF%BC%9ASUPERVISING%20AND%20CORRECTING%20%20LANGUAGE%20MODELS%20WITH%20ERROR-DRIVEN%20INSIGHTS/"},{"title":"每日一题01","text":"每日一题-二分查找 每日一题二分查找 leetcode 704 二分查找https://leetcode.cn/problems/binary-search/ 题解： CPP: 123456789101112131415161718class Solution {public: int search(vector&lt;int&gt;&amp; nums, int target) { int left = 0; int right = nums.size() - 1; while(left &lt; right){ int middle = left + right &gt;&gt; 1; if(nums[middle] &gt;= target){ right = middle; }else{ left = middle + 1; } } if(nums[left] == target) return left; return -1; }}; 1234567891011121314151617class Solution {public: int search(vector&lt;int&gt;&amp; nums, int target) { int left = 0; int right = nums.size() - 1; while(left &lt; right){ int middle = left + right + 1 &gt;&gt; 1; if(nums[middle] &gt; target){ right = middle - 1; }else{ left = middle; } } if(nums[left] == target) return left; return -1; }}; python: 12345678910111213class Solution: def search(self, nums: List[int], target: int) -&gt; int: left, right = 0,len(nums) - 1 while left &lt; right: middle = left + right + 1 &gt;&gt; 1 if nums[middle] &gt; target: right = middle - 1 elif nums[middle] &lt;= target: left = middle if nums[left] == target: return left return -1 12345678910111213class Solution: def search(self, nums: List[int], target: int) -&gt; int: left, right = 0,len(nums) - 1 while left &lt; right: middle = left + right &gt;&gt; 1 if nums[middle] &gt;= target: right = middle elif nums[middle] &lt; target: left = middle + 1 if nums[left] == target: return left return -1 leetcode 35.搜索插入位置https://leetcode.cn/problems/search-insert-position/ 代码： cpp： 123456789101112131415161718class Solution {public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) { int left = 0; int right = nums.size() - 1; if(nums[left] &gt; target) return left; while(left &lt; right){ int middle = left + right + 1 &gt;&gt; 1; if(nums[middle] &gt; target){ right = middle - 1; }else{ left = middle; } } if(nums[left] == target) return left; return left + 1; }}; 1234567891011121314151617class Solution {public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) { int left = 0; int right = nums.size() - 1; if(nums[right] &lt; target) return right + 1; while(left &lt; right){ int middle = left + right &gt;&gt; 1; if(nums[middle] &gt;= target){ right = middle; }else{ left = middle + 1; } } return left; }}; python: 123456789101112class Solution(object): def searchInsert(self, nums, target): left, right = 0, len(nums) - 1 if target &gt; nums[right]: return right + 1 while left &lt; right: middle = left + right &gt;&gt; 1 if nums[middle] &gt;= target: right = middle else: left = middle + 1 return left 1234567891011121314class Solution(object): def searchInsert(self, nums, target): left, right = 0, len(nums) - 1 if target &lt; nums[left]: return left while left &lt; right: middle = left + right + 1 &gt;&gt; 1 if nums[middle] &lt;= target: left = middle else: right = middle - 1 if nums[left] == target: return left return left + 1 leetcode 34.在排序数组中查找元素的第一个和最后一个位置https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/ cpp 123456789101112131415161718192021222324252627282930313233343536class Solution {public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) { if(nums.size() == 0) return {-1, -1}; int left = 0; int right = nums.size() - 1; int leftborder; int rightborder; while(left &lt; right){ int middle = (left + right) &gt;&gt; 1; if(nums[middle] &gt;= target){ right = middle; }else{ left = middle + 1; } } leftborder = left; if(nums[leftborder] != target) return {-1, -1}; else { left = 0; right = nums.size() - 1; while(left &lt; right){ int middle = (left + right + 1) &gt;&gt; 1; if(nums[middle] &gt; target){ right = middle - 1; }else{ left = middle; } } rightborder = left; } return {leftborder, rightborder}; }}; python 12345678910111213141516171819202122232425class Solution: def searchRange(self, nums: List[int], target: int) -&gt; List[int]: if len(nums) == 0: return [-1, -1] left, right = 0, len(nums) - 1 while left &lt; right: middle = left + right &gt;&gt; 1 if nums[middle] &gt;= target: right = middle else: left = middle + 1 if nums[left] != target: return [-1, -1] else: leftboarder = left left = 0 right = len(nums) - 1 while left &lt; right: middle = left + right + 1 &gt;&gt; 1 if nums[middle] &gt; target: right = middle - 1 else: left = middle rightborder = left return [leftboarder, rightborder] leetcode 69.x的平方根https://leetcode.cn/problems/sqrtx/ cpp 1234567891011121314151617class Solution {public: int mySqrt(int x) { if(x &lt;= 1) return x; int left = 0; int right = x / 2 + 1; while(left &lt; right){ int middle = (left + right) &gt;&gt; 1; if((long long)middle * middle &lt;= x){//注意需要进行类型转换，防止int类型无法表示乘积 left = middle + 1; }else{ right = middle; } } return left - 1; }}; python 12345678910111213class Solution: def mySqrt(self, x: int) -&gt; int: if x &lt;= 1: return x left, right = 0, x // 2 + 1 while left &lt; right: middle = (left + right) // 2 if middle * middle &lt;= x: left = middle + 1 else: right = middle return int(left - 1) #需要注意python支持高精度，需要使用整除来表示除法 leetcode367. 有效的完全平方根https://leetcode.cn/problems/valid-perfect-square/ cpp 123456789101112131415161718class Solution {public: bool isPerfectSquare(int num) { long left = 1; long right = num / 2; while(left &lt; right){ long middle = (left + right) / 2; if(middle * middle == num) return true; if(middle * middle &lt; num){ left = middle + 1; }else{ right = middle - 1; } } if (left*left == num) return true; return false; }}; python 1234567891011121314class Solution: def isPerfectSquare(self, num: int) -&gt; bool: left, right = 1, num // 2 while left &lt; right: middle = (left + right) // 2 if middle * middle == num: return True if middle * middle &gt; num: right = middle - 1 else: left = middle + 1 if left * left == num: return True return False","link":"/2024/07/15/%E7%AE%97%E6%B3%95/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"title":"每日一题02","text":"每日一题day2 每日一题双指针算法 leetcode 27 移出元素https://leetcode.cn/problems/remove-element/ 代码: cpp: 12345678910111213class Solution {public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { int fast = 0; int slow = 0; for (fast = 0; fast &lt; nums.size(); fast++){ if(nums[fast] != val){ nums[slow++] = nums[fast]; } } return slow; }}; python: 123456789class Solution: def removeElement(self, nums: List[int], val: int) -&gt; int: slow, fast = 0, 0 for fast in range(len(nums)): if nums[fast] != val: nums[slow] = nums[fast] slow += 1 return slow leetcode 26.删除有序数组中的重复项https://leetcode.cn/problems/remove-duplicates-from-sorted-array/ 代码 cpp: 1234567891011121314class Solution {public: int removeDuplicates(vector&lt;int&gt;&amp; nums) { int fast; int slow = 0; for(fast = 1; fast &lt; nums.size(); fast++){ if(nums[fast] != nums[slow]){ slow++; nums[slow] = nums[fast]; } } return slow + 1; }}; python: 12345678class Solution: def removeDuplicates(self, nums: List[int]) -&gt; int: slow, fast = 0, 1 for fast in range(1, len(nums)): if nums[slow] != nums[fast]: slow += 1 nums[slow] = nums[fast] return slow + 1 leetcode 283.移动零https://leetcode.cn/problems/move-zeroes/ 代码 cpp: 12345678910111213class Solution {public: void moveZeroes(vector&lt;int&gt;&amp; nums) { int fast = 0; int slow = 0; for(fast = 0; fast &lt; nums.size(); fast++){ if(nums[fast] != 0){ swap(nums[slow], nums[fast]); slow++; } } }}; python: 1234567class Solution: def moveZeroes(self, nums: List[int]) -&gt; None: slow, fast = 0, 0 for fast in range(0, len(nums)): if nums[fast] != 0: nums[slow], nums[fast] = nums[fast], nums[slow] slow += 1 leetcode 844比较含退格的字符串https://leetcode.cn/problems/backspace-string-compare/ cpp 12345678910111213141516171819202122232425262728class Solution{public: string returnstringCount(string str){ int size=str.length(); int slow=0; for(int fast=0; fast&lt;size; fast++){ if(str[fast]!='#'){ str[slow++]=str[fast]; } else{ if(slow&gt;0){ // 如果回退到了最后一格就不能再回退了，这里要注意回退的范围 slow--; } } } string str1(str,0,slow); //这里返回实际的字符串 return str1; } bool backspaceCompare(string s,string t){ string sCount = returnstringCount(s); string tCount = returnstringCount(t); if(sCount==tCount){ return true; } return false; // 如果不等，就不用比较，肯定不相等 } }; python 1234567891011121314151617class Solution: def return_string_count(self, s: str) -&gt; str: slow = 0 size = len(s) s = list(s) # 将字符串转换为列表以便进行原地修改 for fast in range(size): if s[fast] != '#': s[slow] = s[fast] slow += 1 else: if slow &gt; 0: slow -= 1 return ''.join(s[:slow]) def backspaceCompare(self, s: str, t: str) -&gt; bool: return self.return_string_count(s) == self.return_string_count(t) leetcode 977. 有序数组的平方https://leetcode.cn/problems/squares-of-a-sorted-array/ cpp 1234567891011121314151617181920class Solution {public: vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) { int n = nums.size(); vector&lt;int&gt; ans(n); int i = 0, j = n - 1; for (int p = n - 1; p &gt;= 0; p--) { int x = nums[i] * nums[i]; int y = nums[j] * nums[j]; if (x &gt; y) { ans[p] = x; i++; } else { ans[p] = y; j--; } } return ans; }}; python 123456789101112131415class Solution: def sortedSquares(self, nums: List[int]) -&gt; List[int]: n = len(nums) ans = [0] * n i, j = 0, n - 1 for p in range(n - 1, -1, -1): x = nums[i] * nums[i] y = nums[j] * nums[j] if x &gt; y: # 更大的数放右边 ans[p] = x i += 1 else: ans[p] = y j -= 1 return ans","link":"/2024/07/16/%E7%AE%97%E6%B3%95/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%9802/"},{"title":"每日一题03","text":"每日一题day3 每日一题滑动窗口leetcode 209 长度最小的子数组https://leetcode.cn/problems/minimum-size-subarray-sum/ 代码： cpp 1234567891011121314151617class Solution {public: int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) { int sum = 0; int j = 0; int res = nums.size() + 10; for(int i = 0; i &lt; nums.size(); i++ ){ sum += nums[i]; while(sum &gt;= target ){ res = min(res, i - j + 1); sum -= nums[j++]; } } res = (res == nums.size() + 10 ? 0 : res); return res; }}; python: 1234567891011121314class Solution: def minSubArrayLen(self, target: int, nums: List[int]) -&gt; int: res = len(nums) + 10 sum = 0 j = 0 for i in range(len(nums)): sum += nums[i] while sum &gt;= target: res = min(res, i - j + 1) sum -= nums[j] j += 1 if res == len(nums) + 10: res = 0 return res leetcode 904 水果成篮https://leetcode.cn/problems/fruit-into-baskets/ 代码： cpp: 12345678910111213141516171819class Solution {public: int totalFruit(vector&lt;int&gt;&amp; fruits) { int res = 0; unordered_map&lt;int, int&gt; cnt; int j = 0; for(int i = 0; i &lt; fruits.size(); i++){ cnt[fruits[i]]++; while(cnt.size() &gt; 2){ auto it = cnt.find(fruits[j]); it-&gt;second--; if(it-&gt;second == 0) cnt.erase(fruits[j]); j++; } res = max(res, i - j + 1); } return res; }}; python 可以使用哈希表cnt维护当前窗口内的水果数量和对应的数量 12345678910111213class Solution: def totalFruit(self, fruits: List[int]) -&gt; int: res = j = 0 cnt = Counter() for i, x in enumerate(fruits): cnt[x] += 1 while len(cnt) &gt; 2: cnt[fruits[j]] -= 1 if cnt[fruits[j]] == 0: cnt.pop(fruits[j]) j += 1 res = max(res, i - j + 1) return res leetcode 76.最小覆盖字串https://leetcode.cn/problems/minimum-window-substring/ 代码: cpp 12345678910111213141516171819202122class Solution {public: string minWindow(string s, string t) { unordered_map&lt;char, int&gt; hs, ht; for(auto c: t) ht[c] ++; int j = 0; string res; int cnt = 0; for(int i = 0; i &lt; s.size(); i ++){ hs[s[i]]++; if(hs[s[i]] &lt;= ht[s[i]]) cnt++; while(hs[s[j]] &gt; ht[s[j]]) hs[s[j++]]--; if(cnt == t.size()){ if(res.empty() || i - j + 1 &lt; res.size()){ res = s.substr(j, i - j + 1); } } } return res; }}; python 12345678910111213141516class Solution: def minWindow(self, s: str, t: str) -&gt; str: ans_left, ans_right = -1, len(s) left = 0 cnt_s = Counter() cnt_t = Counter(t) for right, c in enumerate(s): cnt_s[c] += 1 while cnt_s &gt;= cnt_t: if right - left &lt; ans_right - ans_left: ans_left, ans_right = left, right cnt_s[s[left]] -= 1 left += 1 return &quot;&quot; if ans_left &lt; 0 else s[ans_left: ans_right + 1] 模拟过程leetcode 59 螺旋矩阵https://leetcode.cn/problems/spiral-matrix-ii/ 代码： cpp 12345678910111213141516171819202122232425class Solution {public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) { int maxNum = n * n; int curNum = 1; vector&lt;vector&lt;int&gt;&gt; martix(n, vector&lt;int&gt;(n)); int row = 0; int cloumn = 0; vector&lt;vector&lt;int&gt;&gt; directions = {{0,1}, {1,0}, {0,-1}, {-1,0}}; int index = 0; while(curNum &lt;= maxNum){ martix[row][cloumn] = curNum; curNum ++; int nextRow = row + directions[index][0]; int nextColumn = cloumn + directions[index][1]; if(nextRow &lt; 0 || nextRow &gt;= n || nextColumn &lt; 0 || nextColumn &gt;= n || martix[nextRow][nextColumn] != 0){ index = (index + 1) % 4; } row = row + directions[index][0]; cloumn = cloumn + directions[index][1]; } return martix; }}; python 123456789101112131415class Solution: def generateMatrix(self, n: int) -&gt; List[List[int]]: dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)] matrix = [[0] * n for _ in range(n)] row, col, dirIdx = 0, 0, 0 for i in range(n * n): matrix[row][col] = i + 1 dx, dy = dirs[dirIdx] r, c = row + dx, col + dy if r &lt; 0 or r &gt;= n or c &lt; 0 or c &gt;= n or matrix[r][c] &gt; 0: dirIdx = (dirIdx + 1) % 4 # 顺时针旋转至下一个方向 dx, dy = dirs[dirIdx] row, col = row + dx, col + dy return matrix leetcode 54 螺旋矩阵https://leetcode.cn/problems/spiral-matrix/ 该题同时也是剑指offer146，即LCR 146 螺旋遍历二维数组 https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/ 代码： cpp 1234567891011121314151617181920212223242526272829class Solution {public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { if (matrix.size() == 0 || matrix[0].size() == 0) { return {}; } vector&lt;vector&lt;int&gt;&gt; directions = {{0,1}, {1,0}, {0,-1}, {-1,0}}; int index = 0; int cnt = 0; vector&lt;vector&lt;bool&gt;&gt; visit(matrix.size(),vector&lt;bool&gt;(matrix[0].size())); vector&lt;int&gt; res(matrix.size() * matrix[0].size()); int row = 0; int column = 0; while(cnt &lt; matrix.size()*matrix[0].size()){ res[cnt] = matrix[row][column]; visit[row][column] = true; cnt ++ ; int nextRow = row + directions[index][0]; int nextColumn = column + directions[index][1]; if(nextRow &lt; 0 || nextRow &gt;= matrix.size() || nextColumn &lt; 0 || nextColumn &gt;= matrix[0].size() || visit[nextRow][nextColumn]){ index = (index + 1) % 4; } row = row + directions[index][0]; column = column + directions[index][1]; } return res; }}; python 12345678910111213141516171819class Solution: def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]: rows = len(matrix) columns = len(matrix[0]) visit = [[False]*columns for _ in range(rows)] res = [0] * (rows * columns) row, column = 0, 0 directions = [[0,1],[1,0],[0,-1],[-1,0]] index = 0 for i in range(rows * columns): res[i] = matrix[row][column] visit[row] [column] = True nextRow = row + directions[index][0] nextColumn = column + directions[index][1] if nextRow &lt; 0 or nextRow &gt;= rows or nextColumn &lt; 0 or nextColumn &gt;= columns or visit[nextRow][nextColumn]: index = (index + 1) % 4 row += directions[index][0] column += directions[index][1] return res","link":"/2024/07/25/%E7%AE%97%E6%B3%95/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%9803/"},{"title":"每日一题05","text":"每日一题day5 每日一题哈希表 python中defaultdict类的使用： https://blog.nowcoder.net/n/2aef535877a84165b8b7d99032ecbf09 python中Counter类的使用： https://blog.csdn.net/sinat_28576553/article/details/99131954","link":"/2024/07/26/%E7%AE%97%E6%B3%95/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%9805/"},{"title":"每日一题04","text":"每日一题day4 每日一题链表定义 cpp 12345struct ListNode{ int val; ListNode *next; ListNode(int x) : val(x),next(NULL) {}} python 1234class ListNode: def __init__(self, val, next = None): self.val = val self.next = next 移除链表元素https://leetcode.cn/problems/remove-linked-list-elements/ cpp 12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* removeElements(ListNode* head, int val) { while(head != NULL &amp;&amp; head-&gt;val == val){ ListNode* temp = head; head = head-&gt; next; delete temp; } ListNode* cur = head; while(cur != NULL &amp;&amp; cur-&gt;next != NULL){ if(cur-&gt;next-&gt;val == val){ ListNode* temp = cur-&gt;next; cur-&gt;next = cur-&gt;next-&gt;next; delete temp; }else{ cur = cur-&gt;next; } } return head; }}; python 12345678910111213141516# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def removeElements(self, head: Optional[ListNode], val: int) -&gt; Optional[ListNode]: while head != None and head.val == val: head = head.next cur = head while cur != None and cur.next != None: if cur.next.val == val: cur.next = cur.next.next else: cur = cur.next return head leetcode 707 设计链表https://leetcode.cn/problems/design-linked-list/ 代码： cpp 123456```**python**```python","link":"/2024/07/26/%E7%AE%97%E6%B3%95/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%9804/"}],"tags":[{"name":"编程语言","slug":"编程语言","link":"/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"数据结构算法","slug":"数据结构算法","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/"},{"name":"NLP","slug":"NLP","link":"/tags/NLP/"},{"name":"LLM","slug":"LLM","link":"/tags/LLM/"},{"name":"ReasoningModel","slug":"ReasoningModel","link":"/tags/ReasoningModel/"}],"categories":[{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"NLP","slug":"NLP","link":"/categories/NLP/"},{"name":"Research","slug":"Research","link":"/categories/Research/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"}],"pages":[{"title":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：https://removeif.github.io/images/avatar.jpg 网站名称：辣椒の酱 网站地址：https://removeif.github.io 网站简介：后端开发，技术分享 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"","text":"个人简介 分享很喜欢的老罗的一段话： “每一个生命来到世间都注定改变世界，别无选择。要么变得好一点，要么变得坏一点。你如果走进社会为了生存为了什么不要脸的理由，变成了一个恶心的成年人社会中的一员，那你就把这个世界变得恶心了一点点。如果你一生刚正不阿，如果你一生耿直，没有做任何恶心的事情，没做对别人有害的事情，一辈子拼了老命勉强把自己身边的几个人照顾好了，没有成名没有发财，没有成就伟大的事业，然后耿着脖子一生正直，到了七八十岁耿着脖子去世了。你这一生是不是没有改变世界？你还是改变世界了，你把这个世界变得美好了一点点。因为世界上又多了一个好人。“ 善恶终有报,天道好轮回。不信抬头看,苍天饶过谁。无论何时何地，我们都要保持一颗积极乐观、善良感恩的心。但行好事莫问前程，永远年轻，永远热内盈眶，永远保持正能量。💪💪💪💪💪💪冲鸭！！！！ -&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;个人信息：计算机科学与技术专业从事JAVA后端开发码畜一枚坚信代码改变世界 博客信息 网站采用的Icarus主题 追求尽可能的简洁，清晰，易用。 在Icarus主题之上进行了部分修改。 更新日志：–2020.09.20：icarus4.0适配–2020.01.18：icarus3.0适配–2019.11.17：增加深色主题开关–2019.10.30：去图，精简卡片–2019.10.22：改版部分显示，优化速度–2019.10.16：文章列表加上评论数显示–2019.10.13：改版评论–2019.09.25：图片、资源接入CDN免费jsDelivr、文章加入置顶–2019.09.19：开源博客代码–2019.09.19：修改布局，拉伸布局，更宽的展示–2019.09.18：修改友链ui为一行三个，并适配移动端，暗黑模式文章增加评论链接，增加留言链接–2019.09.14：增加精简next主题–2019.09.14：利用中秋节放假，重做了首页的热门推荐、加个widget最新评论框、归档页加入文章贡献概览面板 本站推荐索引 博客主题相关 github Issue 作为博客微型数据库的应用 github page网站cdn优化加速 博客源码分享 博客换肤的一种实现方式思路 博客中gitalk最新评论的获取 博客图片上传picgo工具github图传使用 安装、部分配置icarus主题中文版 技术知识点 Java并发知识点 法律法规 法律法规数据库 中华人民共和国国旗法 中华人民共和国宪法 中华人民共和国消费者权益保护法 中华人民共和国刑事诉讼法 中华人民共和国婚姻法 中华人名共和国网络安全法 中华人民共和国劳动法 其他 网易云音乐歌单分享 计划2020计划 2019.12.31 2020-GOALS 跑两三场马拉松 2019计划 2018.12.31/21:59:00-&gt;更新于2019.12.31 2019-GOALS 购买的专业书籍至少看完一遍（并发、重构、设计模式…）-&gt; 95%额外： 追了很多剧总结： 有优点有缺点，没坚持下来的还是太多，追了太多剧。以后多学习，多思考！ 时间轴记录","link":"/about/index.html"},{"title":"音乐歌单收藏","text":"温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"},{"title":"","text":"🎈🎈微笑墙🎈🎈 彭小苒 唐艺昕 李一桐 gakki 图片搜集于互联网，侵权请留言，马上处理😊。","link":"/album/index.html"},{"title":"","text":"碎碎念 tips：github登录后按时间正序查看、可点赞加❤️、本插件地址..「+99次查看」 碎碎念加载中，请稍等... $.getScript(\"/js/gitalk_self.min.js\", function () { var gitalk = new Gitalk({ clientID: '46a9f3481b46ea0129d8', clientSecret: '79c7c9cb847e141757d7864453bcbf89f0655b24', id: '666666', repo: 'issue_database', owner: 'removeif', admin: \"removeif\", createIssueManually: true, distractionFreeMode: false }); gitalk.render('comment-container1'); });","link":"/self-talking/index.html"}]}